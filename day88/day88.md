2022.12.14



# 第12章 动态内存
到目前为止，我们编写的程序中所使用的对象都有着严格定义的生存期。全局对象在程序启动时自动分配，在程序结束时销毁。对于局部自动对象，当我们进入其定义所在的程序块时创建，在离开块时销毁。局部static对象在第一次使用前分配，在程序结束时销毁。

除了自动和static对象外，C++还支持动态分配对象。动态分配对象的生存期与它们在哪里创建是无关的，只有当显式的被释放时，这些对象才会销毁。

动态对象的正确释放被证明是编程中极其容易出错的地方。为了更安全的使用动态对象，标准库定义了两个智能指针类型来管理动态分配的对象。当一个对象应该被释放时，指向它的智能指针可以确保自动的释放它。

我们的程序到目前为止只是用过静态内存或栈内存。静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。

除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间(free store)或堆。程序用堆来存储动态分配(dynamically allocate)的对象————即，那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们呢的代码必须显式的销毁它们。

**WARNING: 虽然使用动态内存有时是必要的，但众所周知，正确的管理动态内存是非常棘手的**

## 12.1动态内存与智能指针
在C++中，动态内存的管理是通过一堆运算符来完成的:new，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择堆对象进行初始化;delete,接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。

动态内存的使用很容易出问题，因为确保在正确的时间释放内存是极其困难的。有时我们会忘记释放内存，在这种情况下就会产生内存泄露；有时在尚有指针引用内存的情况下我们就释放了它，在这种情况下就会产生引用非法内存地址的指针。

为了更容易(同时也更安全)的使用动态内存，新的标准库提供了两种智能指针(smart pointer)类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式:

shared_ptr允许多个指针指向同一个对象；

unique_ptr则"独占"所指向的对象。

标准库还定义了一种名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在memory头文件中。

### 12.1.1 shared_ptr类
类似vector，智能指针也是模板。因此，当我们创建一个智能指针时，必须提供额外的信息————指针可以指向的类型。与vector一样，我们再尖括号内给出类型，之后是所定义的这种智能指针的名字:

```c++
shared_ptr<string> p1;  // shared_ptr，可以指向string
shared_ptr<list<int>> p2;  // shared_ptr,可以指向int的list
```

默认初始化的智能指针中保存着一个空指针。

智能指针的使用方式与普通指针类似。解引用一个智能指针返回它指向的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空:

```c++
// 如果p1不为空，检查他是否指向一个空string
if (p1 && p1->empty()) {
    *p1 = "hi";  // 如果p1指向一个空string，解引用p1，将一个新值赋予string
}
```

表12.1列出了shared_ptr和unique_ptr都支持的操作。只适用于shared_ptr的操作于表12.2中。