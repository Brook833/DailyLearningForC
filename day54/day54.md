2022.11.09



# 第9章 顺序容器
一个容器就是一些特定类型对象的集合。

顺序容器为程序提供了元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。

表尊库还提供了三种容器适配器，分别为容器操作定义了不同的接口，来与容器类型适配

## 9.1 顺序容器概述
所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中:
> + 向容器添加或从容器中删除元素的代价。
> + 非顺序访问容器中元素的代价。

| 顺序容器类型 |  |
|:-|:-|
| vector | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢 |
| deque | 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快 |
| list | 双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作都很快 |
| forward_list | 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快 |
| array | 固定大小数组。支持快速随机访问。不能添加或删除元素 |
| string | 与vector相似的容器，但专门用于保存字符。随机访问快，在尾部插入/删除速度快 |

除了固定大小的array外，其他容器都提供高效，灵活的内存管理。我们可以添加和删除元素，扩张和收缩容器的大小。容器保存元素的策略对容器操作的效率有着固有的，有时是重大的影响。在某些情况下，存储策略还会影响特定容器是否支持特定操作。

例如,string和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常迅速的。但是，在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入或删除操作后，需要移动插入/删除位置之后的所有元素，来保持连续存储。而且，添加一个元素有时可能还需要分配额外的存储空间。在这种情况下，每个元素都必须移动到新的存储空间中。

list和forward_list两个容器的设计目的是令容器任何位置的添加和删除操作都很迅速。作为代价，这两个容器不支持元素的随机访问：为了访问一个元素，我们只能遍历整个容器。而且，与vector、deque和array相比，这两个容器的额外内存开销也很大。

deque是一个更为复杂的数据结构。与string和vector类似，deque支持快速的随机访问。与string和vector一样，在deuqe的中间位置添加或删除元素的代价(可能)很高。但是，在deque的两端添加或删除元素都是很快的，与list或forward_list添加删除元素的速度相当。

forward_list和array是薪C++标准增加的类型。与内置数组相比，array是一种更安全、更容易使用的数组类型。与内置数组类似，array对象的大小是固定的。因此，array不支持添加和删除元素以及改变容器大小的操作。forward_list的设计目标是达到与最好的手写的单向链表数据结构相当的性能。因此，forward_list没有size操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容器而言，size保证是一个快速的常量时间的操作。

**Note:  新标准库的容器比旧版本快得多。新标准库容器的性能几乎肯定与最精心优化的同类数据结构一样好(通常会更好)。现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。**

### 确定使用哪种顺序容器
**Tip: 通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。**
以下是一些选择容器的基本原则：
> + 除非有很好的理由选择其他容器，否则应使用vector。
> + 如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list。
> + 如果程序要求随机访问元素，应使用vector或deque。
> + 如果程序要求在容器的中间添加或删除元素，应使用list或forward_list。
> + 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入和删除操作，则使用deque。
> + 如果程序只有在读取输入时才需要在容器中间插入元素，随后需要随机访问元素，则，首先确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很轻易的向vector追加数据，然后在调用标准库的sort函数来重排容器中的元素，从而避免在中间位置添加元素。如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector中。

如果程序既需要随机访问元素，又需要在容器中间位置插入元素，那该怎么办？答案取决于在list或forward_list中访问元素与vector中deque中插入/删除元素的相对性能。一般来说，应用中占主导地位的操作(执行的访问操作更多还是插入/删除更多)决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了。

**Best practices:如果不确定应该使用哪些容器，那么可以在程序中只使用vector和list公共的操作：使用迭代器，不使用下标操作，避免随机访问。这样，在必须要是选择vector或list都很方便**

## 9.2 容器库概览
容器类型上的操作形成了一种层次：
> + 某些操作是所有容器类型都提供的。
> + 另外一些操作仅针对顺序容器或无序容器。
> + 还有一些操作只适用于一小部分容器

本节中将介绍对所有容器都适用的操作。本章剩余部分仅适用于顺序容器的操作。关联容器特有的操作将在第11章介绍。

一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。即，deque定义在头文件deque中，list定义在头文件list中，以此类推。容器均定义为模板类。例如vector，我们必须提供额外信息来生成特定的容器类型。对大多数，但不是所有容器，我们还要额外提供元素类型信息：

```c++
list<Sales_data>  // 保存Sales_data对象的list
deque<double>  // 保存double的deque
```

### 对容器可以保存的元素类型的限制
顺序容器几乎可以保存任意类型的元素。特别是，我们可以定义一个容器，其元素的类型是另一个容器。这种容器的定义与任何其他容器类型完全一样：在尖括号中指定元素类型(此种情况下，是另一种容器类型)：

```c++
vector<vector<string>> lines;  //  vector的vector。
```

此处lines是一个vector，其元素类型是string的vector。

**Note:较旧的编译器可能需要在两个尖括号之间键入空格，例如，vector<vecotr<string> >**

虽然我们可以在容器中保存几乎任何类型，但某些容器操作对元素类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况下就只能使用那些没有特殊要求的容器操作了。

例如，顺序容器构造函数的一个版本接受容器大小参数，它使用了元素类型默认的构造函数，但某些类没有默认构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能值传递给他一个元素数目参数：

```c++
// 假定noDefault是一个没有默认构造函数的类型
vector<noDefault> v1(10, init);  // 正确，提供了元素初始化器
vector<noDefault> v2(10);  // 错误，必须提供一个元素初始化器
```

当后面介绍容器操作时，我们还会注意到每个容器对元素类型的其他限制。

| 容器操作 |  |
|:-|:-|
| **类型别名** |  |
| iterator | 此类型的迭代器类型 |
| const_iterator | 可以读取元素，但不能修改元素的迭代器类型 |
| size_type | 无符号整数类型，足够保证此种容器类型最大可能容器的大小 |
| difference_type | 带符号整数类型，足够保存两个迭代器之间的距离 |
| value_type | 元素类型 |
| reference | 元素的左值类型: 与value_type&含义相同 |
| const_reference | 元素的const左值类型(即,const value_type&) |
| **构造函数** |  |
| C c; | 默认构造函数，构造空容器 |
| C c1(c2); | 构造c2的拷贝c1 |
| C c(b, e); | 构造c,将迭代器b和e指定范围内的元素拷贝到c(array不支持) |
| C{a, b, c}; | 列表初始化c |
| **赋值与swap** |
| c1 = c2 | 将c1中的元素替换为c2中元素 |
| c1 = {a, b, c}; | 将c1中元素替换为列表中元素(不适用于array) |
| a.swap(b) | 交换a和b的元素 |
| swap(a, b) | 与a.swap(b)等价 |
| **大小** |  |
| c.size() | c中元素的数目(不支持forward_list) |
| c.max_size() | c可保存的最大元素数目 |
| c.empty() | 若c中存储了元素，返回false,否则返回true |
| **添加/删除元素(不适用于array)(在不同容器中，这些操作的接口都不同)** |  |
| c.insert(args) | 将args中的元素拷贝进c |
| c.emplace(inits) | 使用inits构造c中的一个元素 |
| c.erase(args) | 删除args指定的元素 |
| c.clear() | 删除c中的所有元素，返回void |
| **关系运算符** |  |
| ==, != | 所有容器都支持相等(不等)运算符 |
| <, <=, >, >= | 关系运算符，(无需关联容器不支持) |
| **获取迭代器** |  |
| c.begin(), c.end() | 返回指向c的首元素和尾元素之后位置的迭代器 |
| c.cbegin(), c,cend() | 返回const_iterator |
| **反向容器的额外成员(不支持forward_list)** |  |
| reverse_iterator | 按逆序寻址元素的迭代器 |
| const_reverse_iterator | 不能修改元素的逆序迭代器 |
| c.rbegin(), c.rend() | 返回指向c的尾元素和首元素之前位置的迭代器 |
| c.crbegin(), c,crend() | 返回const_reverse_iterator |

