2022.11.28



### 引用捕获
我们定义lambda时可以采用引用方式捕获变量。例如:

```c++
void fcn2() {
    size_t v1 = 42;  // 局部变量
    auto f2 = [&v1]{ return v1; }  // 对象f2包含v1的引用
    v1 = 0;
    auto j = f2();  // j为0；f2保存v1的引用，而非拷贝
}
```

v1之前的&指出v1应该以引用方式捕获。一个以引用方式捕获的变量与其他任何类型的引用行为类似。当我们在lambda函数体内使用此变量时，实际上使用的时引用所绑定的对象。在本例中，当lambda返回v1时，它返回的是指向的对象的值。

引用捕获与返回引用有着相同的问题和限制。如果我们采用引用方式捕获一个变量，就必须确保被引用的对象在lambda执行的时候是存在的。lambda捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果lambda可能在函数结束后执行。捕获的引用指向的局部变量已经消失。

引用捕获有时是必要的。例如，我们可能希望biggies函数接受一个ostream的引用，用来输出数据，并接受一个字符作为分隔符:

```c++
void biggies(vector<string> &words, vector<string::>size_type sz, ostream &os = cout, char c = ' ') {
    // 排序算法
    for_each(words.begin(), words.end(), [&os, c](const string &s){ os << s << c; });
}
```

我们不能拷贝ostream对象，因此捕获os的唯一方法就是捕获其引用(或指向os的指针)。

当我们向一个函数传递一个lambda时，就像本例中调用for_each那样，lambda会立即执行。再此情况下，以引用方式捕获os没有问题，因为当for_each执行时，biggies中的变量是存在的。

我们也可以从一个函数返回lambda。函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个lambda，则与函数不能返回一个局部变量的引用类似，此lambda也不能包含引用捕获。

**WARNING: 当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的**

==建议:尽量保持lambda的变量捕获简单化
一个lambde捕获从lambda被创建(即，定义lambda的代码执行时)到lambda自身执行(可能多次执行)这段时间内保存的相关信息。确保lambda每次执行的时候这些信息都有预期的意义，时程序员的责任。
捕获一个普通变量，如int、string或其他非指针类型，通常可以采用简单的值捕获方式。在此情况下，只需要关注变量在捕获时是否有我们所需的值就可以了。
如果我们捕获一个指针或一个迭代器，或采用引用捕获方式，就必须确保在lambda执行时，绑定到迭代器、指针或引用的对象仍然存在。而且，需要保证对象具有预期的值。在lambda从创建到它被捕获的时刻，绑定的对象的值是我们所期望的，但在lambda执行时，该对象的值可能已经完全不同了。
一般来说，我们应该尽量减少捕获的数据量，来避免潜在的捕获导致的问题。而且，如果可能的话，应该避免捕获指针或引用。==

### 隐式捕获
除了显式列出我们希望使用的来自所在的函数的变量之外，还可以让编译器根据lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获泪飙，应在捕获列表中写一个&或=。&告诉编译器采用捕获引用方式，=则表示采用值捕获方式。例如，我们可以重写传递给find_if的lambda:

```c++
// sz为隐式捕获，值捕获方式
wc = find_if(words.begin(), words.end(), [=](const string &s){ return s.size() >= sz; });
```

如果我们希望对一部分变量采用值捕获对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获:

```c++
void biggies(vector<string> &words， vector<string>::size_type sz, ostream &os = cout, char c = ' ') {
    // 排序算法
    // os隐式捕获，引用捕获方式；c显式捕获，值捕获方式
    for_each(words.begin(), words.end(), [&, c](const string &s){ os << s << c; });
    // os显式捕获，引用捕获方式，c隐式捕获，值捕获方式
    for_each(words.begin(), words.end(), [=, &s](const string &s){ os << s << c; });
}
```

当我们混合使用隐式捕获和显式捕获时，捕获列表中第一个元素必须是一个&或=。此符号指定了默认捕获方式。

当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。即，如果隐式捕获是引用方式(使用了&)，则显式捕获明明变量时必须采用值方式，因此不能在其名字前使用&。类似的，如果隐式捕获采用的是值方式(使用了=)，则显式捕获命名时必须采用引用方式，即在名字前使用&。

| **表10.1: lambda捕获列表** |  |
|:- |:- |
| [] | 空捕获列表。lambda不能使用所在函数中的变量。一个lambda只有捕获变白了后才能使用它们 |
| [names] | names是一个逗号分隔的名字列表，这些名字都是lambda所在函数的局部变量。默认情况下，捕获列表中的变量都被拷贝。名字前如果使用了&，则采用引用捕获方式 |
| [&] | 隐式捕获列表，采用引用捕获方式。lambda体内所使用的来自所在函数的实体都采用引用方式使用 |
| [=] | 隐式捕获列表，采用引用值方式。lambda体内将拷贝所使用的来自所在函数的实体的值 |
| [&, list] | list是一个逗号分隔的列表，包含0个或多个来自所在函数的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。list中的名字前面不能使用& |
| [=, list] | list中的变量都采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。list中的名字不能包括this，且这些名字前必须使用& |

