2022.12.05


## 10.6 特定容器算法
与其他容器不同，链表类型list和forward_list定义了几个成员函数形式的算法，如表10.6所示。特别是，它们定义了独有的sort、merge、remove、reverse和unique。通用版本的sort要求随机访问迭代器，因此不能用于list和forward_list，因为这两个类型分别提供双向迭代器和前向迭代器。

链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真的交换它们的值来快速"交换"元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。

**Best Practices: 对于list和forward_list，应该优先使用成员函数版本的算法而不是通用算法。**

| **表10.6: list和forward_list成员函数版本的算法** |  |
| 这些操作都返回void |  |
| lst.merge(lst2) | 将来自lst2的元素合并入lst。lst和lst2都必须是有序的。元素将从lst2中删除。在合并之后，lst2变为空。第一个版本使用<运算符:第二个版本使用给定的比较操作 |
| lst.merge(lst2.comp) |  |
| lst.remove(val) | 调用erase删除掉与给定值相等(==)或令一元谓词为真的每个元素 |
| lst.remove_if(pred) |  |
| lst.reverse() | 反转lst中元素的顺序 |
| lst.sort() | 使用<或==比较操作排序元素 |
| lst.sort(comp) |  |
| lst.unique() | 调用erase删除同一个值的连续拷贝。第一个版本使用==；第二个版本使用给定的二元谓词 |
| lst.unique(pred) |  |

### splice成员
链表类型还定义了splice算法，其描述见表10.7。此算法是链表数据结构所特有的，因此不需要通用版本。

| **表10.7: list和forward_list的splice成员函数的参数** |  |
| lst.splice(args)或flst.splice_after(args) |  |
| (p, lst2) | p是一个指向lst中元素的迭代器，或一个指向flst首前位置的迭代器。函数将lst2所有元素移动到lst中p之前的位置或是flst中p之后的位置。将元素从lst2中删除。lst2的类型必须与lst或flst相同，且不能是同一个链表 |
| (p, lst2, p2) | p2是一个指向lst2中位置的有效的迭代器。将p2指向的元素移动到lst1中，或将p2之后的元素移动到flst中。lst2可以是与lst或flst相同的链表。 |
| (p, lst2, b, e) | b和e必须表示lst2中的合法范围。将给定范围的元素从lst2移动到lst或flst。lst2与lst(或flst)可以是相同的链表，但p不能指向给定范围中的元素。 |

### 链表特有的操作会改变容器
多数链表特有的算法与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变低层的容器。例如，remove的链表版本会删除指定的元素。unique的链表版本会删除第二个和后继的重复元素。

类似的，merge和splice会销毁其参数。例如，通用版本的merge将合并的序列写到一个给定的目的迭代器;两个输入序列是不变的。而链表版本的merge函数会销毁给定的链表————元素从参数指定的链表中删除，被合并到调用merge的链表对象中。在merge之后，来自两个链表中的元素仍然存在，但它们都已在同一个链表中。

# 第11章 关联容器
关联容器和顺序容器有着根本的不同:关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。

虽然关联容器的很多行为与顺序容器相同，但其不同之处反映了关键字的作用。

关联容器支持高效的关键字查找和访问。两个主要的关联容器(associative-container)类型是map和set。map中的元素是一些关键字-值(key-value)对:关键字起到索引的作用，值则表示与索引相关联的数据。set中每个元素只包含了一个关键字;set支持高效的关键字查询操作--检查一个给定关键字是否在set中。例如，在某些文本处理过程中，可以用一个set来保存想要忽略的单词。字典是一个很好的使用map的例子:可以将单词作为关键字，将单词释义作为值。

标准库提供8个关联容器，如表11.1所示。这8个容器的不同体现在三个维度上:每个容器(1)或者是一个set，或者是一个map;(2)或者要求不重复的关键字，或者允许重复关键字;(3)按照顺序保存元素，或无序保存。允许重复的关键字的容器的名字中都包含单词multi；不保持关键字按顺序存储的哦让其的名字都以单词unordered开头。因此一个unordered_multi_set是一个允许重复关键字，元素无序保存的集合，而一个set则是一个要求不重复关键字,有序存储的集合。无序容器使用哈希函数来组织元素。

类型map和multimap定义在头文件map中;set和multiset定义在头文件set中;无序容器则定义在头文件unordered_map和unordered_set中。

| **表11.1: 关联容器类型** |  |
|:- |:- |
| **按关键字有序保存元素** |  |
| map | 关联数组；保存关键字-值对 |
| set | 关键字即值，即只保存关键字的容器 |
| multimap | 关键字可重复出现的map |
| multiset | 关键字可重复出现的set |
| **无序集合** |  |
| unordered_map | 用哈希函数组织的map |
| unordered_set | 用哈希函数组织的set |
| unordered_multimap | 哈希组织的map;关键字可以重复出现 |
| Unordered_multiset | 哈希组织的set;关键字可以重复出现 |

## 11.1 使用关联容器
虽然大多数程序员都熟悉诸如vector和list这样的数据结构，但它们中很多人从未使用过关联数据结构。在学习标准库关联容器类型的详细内容之前，我们首先来看一个如何使用这类容器的例子，这对后续学习很有帮助。

map是关键字-值对的集合。例如，可以将一个人的名字作为关键字，将其电话号码作为值。我们称这样的数据结构为"将名字映射到电话号码"。map类型通常被称为关联数组(associative array)。关联数组与"正常"数组类似，不同之处在于其下标不必是整数。我们通过一个关键字而不是位置来查找值。给定一个名字到电话号码的map，我们可以使用一个人的名字作为下标来获取此人的电话号码。

与之相对，set就是关键字的简单集合。当只想知道一个值是否存在时，set是最有用的。例如，一个企业可以定义一个名为bad_checks的set来保存那些曾经开过空头支票的人的名字。在接受一张支票之前，可以查询bad_checks来检查顾客的名字是否在其中。

### 使用map
一个经典的使用关联数组的例子是单词计数程序:

```c++
// 统计每个单词在输入中出现的次数
map<string, size_t> word_count;  // string到size_t的空map
string word;
while(cin >> word) {
    ++word_count[word];  // 提取word的计数器并将其加1
}
for (const auto &w : word_count) {  // 对map中每个元素
    // 打印结果
    cout << w.first << " occurs " << w.second << ((w.second > 1) ? " times" : " time") << endl;
}
```

此程序读取输入，报告每个单词出现多少次。

类似顺序容器，关联容器也是模板。为了定义一个map，我们必须指定关键字和值的类型。在此程序中，map保存的每个元素中，关键字是string类型，值是size_t类型。当对word_count进行下标操作时，我们使用一个string作为下标，获得与此string相关联的size_t类型的计数器。

while循环每次从标准输入读取一个单词。它使用每个单词对word_count进行下标操作。如果word还未在map中，下标运算符会创建一个新元素，其关键字为word，值为0.不管元素是否新创建的，我们将其值加1。

一旦读取完所有输入，范围for语句就会遍历map，打印每个单词和对应的计数器。当从map中提取一个元素时，会得到一个pair类型对象。简单来说，pair是一个模板类型，保存连个名为first和second的(公有)数据成员。map所使用的pair用first成员保存关键字，用second成员保存对应的值。因此，输出语句的效果时打印每个单词及其关联的计数器。

### 使用set
上一个实例程序的一个合理拓展是:忽略常见单词，如"the"、"and"、"or"等。我们可以使用set保存想忽略的单词，只对不在集合中的单词统计出现次数:

```c++
map<string, size_t> word_count;
set<string> exclude = {"The", "But", "And"};
string word;
while (cin >> word) {
    if (exclude.find(word) == exclude.end()) {
        ++word_count[word];
    }
}
```

与其他容器类似，set也是模板。为了定义一个set，必须指定其元素类型，本例中是string。与顺序容器类似，可以对一个关联容器进行列表初始化。集合exclude保存了我们想忽略的单词。

此程序与前一个程序的重要不同是，在统计每个单词出现次数之前，我们检查单词是否在忽略结合中，这是在if语句中完成的。

find返回一个迭代器，如果给定关键字在set中，迭代器指向该关键字。否则，find返回尾后迭代器。此程序中，仅当word不在exclude中时，我们才更新word的计数器。