2022.10.16
学习C++primer 6.5特殊用途语言特性


### 默认实参
某些函数有这样一种形参，在函数的很多次调用中他们都被赋予一个相同的值，此时，我们把这个反复出现的值成为函数的默认实参。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。
```c++
typedef string::string_type sz;
string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');
```
其中我们为每一个实参都提供了默认实参，默认实参作为形参的初始值出现在形参列表中。我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。

### 使用默认实参调用函数
如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。

screen函数为它所有的形参都提供了默认实参，所以我们可以使用0，1，2或3个实参调用该函数。
```c++
string window;
window = screen(); //等价与screen(24, 80, ' ');
window = screen(66); //等价于screen(66, 80, ‘ ’)；
window = screen(66, 256); //等价于screen(66, 256, ' ');
window = screen(66, 256, '#'); //等价于screen(66, 256, '#');
```
函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参(靠右侧位置)。

### 默认实参声明
对于函数的声明来说，通常的习惯是将其放在头文件中，并且一个函数只声明一次，但是多次声明对于同一个函数也是合法的。不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认实参的形参添加默认实参，而且该形参右侧的所有形参必须有默认值。
```c++
string screen(sz, sz, char = ' '); //高度和宽度的形参没有默认值
string screen(sz, sz, char = '*'); //错误，我们不能修改一个已经存在的默认实参。
string screen(sz = 24, sz = 80, char); //正确
```
通常，应该在函数生命中指定默认实参，并将该声明放在合适的头文件中。

### 默认实参初始值
局部变量不能作为默认实参。除此之外，只要表达式的类型能够转换成形参所需的类型，该表达式就能作为默认实参。

用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时：
```c++
void f2() {
  def = '*'; //改变默认实参的值
  sz wd = 100; //隐藏了外层定义的wd,但是没有改变默认值
  window = screen(); //调用screen(ht(), 80, '*');
}
```
我们在函数f2内部改变了def的值，所以对screen的调用将会传递这个更新过的值。另一方面，虽然我们的函数还声明了一个局部变量用于隐藏外层的wd，但是该局部变量与传递给screen的默认实参没有任何关系。

### 内联函数和constexpr函数
把规模较小的操作定义成函数有很多好处，主要包括：

阅读和理解函数的调用要比读懂等价的条件表达式容易得多。

使用函数可以确保行为的同意，每次相关操作都能按照同样的方式进行。

如果我们需要修改计算过程，显然修改函数要比先找到等价表达式所有出现的地方再逐一修改等价表达式所有出现的地方再逐一修改更容易。

函数可以被其他应用重复利用，省去了程序员重新编写的代价。

然而，使用函数也存在一个潜在的缺点：调用函数一半比求等价表达式的值要慢一些。

在大多数机器上，一次性函数调用其实包含着一些列工作：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。

### 内联函数可避免函数调用的开销
将函数指定为内联函数(inline)，通常就是将它在每个调用点上展开，从而消除了函数运行时的开销。

在函数的返回类型前面加上关键字inline，这样就可以将它声明成内联函数了。(内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求)

一般来说，内联机制用于优化规模较小，流程直接，频繁调用的函数。很多编译器都不支持内联递归函数。

### constexpr函数
constexpr函数是指能用于常量表达式的函数。定义constexpr函数的昂发与其他函数类似，不过要遵循几项约定；函数的返回值类型以及所有的形参类型都得是字面值类型，而且函数体中必须有且只有一条return语句。

为了能在编译过程中随时展开，constexpr函数被隐式的指定为内联函数。

constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作，如空语句，类型别名，using声明。

当scale的实参是常量表达式时，它的返回值也是常量表达式。
```c++
constexpr size_t cscale(size_t cnt) { return new_sz() * cnt; } //如果arg是常量表达式，那么scale(arg)也是常量表达式。
```
constexpr函数不一定返回常量表达式。

### 把内联函数和constexpr函数放在头文件内
和其他函数不一样，内联函数和constexpr函数可以在程序中多次定义。毕竟，编译器要想展开函数仅有函数声明是不够的，还需要函数的定义。不过，对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。

### 调试帮助
C++程序员有时会用到一种类似于头文件保护的技术，一边有选择的执行调试代码。基本思想是，程序可以包含一些用于调试的代码，但是这些代码旨在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG。

### assert预处理宏
assert时一种预处理宏，所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表达式作为他的条件。

assert(expr)；

首先对expr求值，如果表达式为假(即0)，assert输出信息并终止程序的执行。如果表达式为真，assert什么也不做。

assert宏定义在cassert头文件中，如我们所致，预处理名字由预处理器而非编译器管理，因此我们可以直接使用预处理名字而无须提供using声明。也就是说我们呢应该使用assert而不是std::assert，也不需要提供using声明。

和预处理变量一样，宏名字在程序内必须唯一。含有cassert头文件的程序不能再定义名为assert的变量、函数或者其他实体。在实际编程过程中，即使我们没有包含cassert头文件，也最好不要为了其他目的使用assert。很多头文件都包含了cassert。

assert宏常用于检查"不能发生"的条件。

### NDEBUG预处理变量
assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有NDEBUG，此时assert将执行运行时检查。

我们可以提供一个#define语句定义NDEBUG，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项是我们可以定义预处理变量。

定义NDEBUG能避免检查各种条件所需的运行时开销，当然此时根本就不会执行运行时检查。因此，assert应该仅用于验证那些确实不可能发生的事情。我们可以把assert当成调试程序的一种辅助手段，但是不能用它替代真正的运行时逻辑检查，也不能替代程序本身应该包含的错误检查。

除了用于assert外，也可以使用NDEBUG编写自己的条件调试代码。如果NDEBUG未定义，将执行#ifndef和#endif之间的代码。
```c++
void print(const int ia(), size_t size) {
#ifndef NDEBUG
    // __fun__是编译器定义的一个局部静态变量，用于存放函数的名字
    cerr << __func__ << ": array size is " << size << endl;
#endif
}
```
在这段代码中，我们使用变量__func__输出当前调试的函数的名字。编译器为每个函数都定义了__func__，它是const char的一个静态数组，用于存放函数的名字。

除了C++编译器定义的__func__之外，预处理器还定义了另外4个对于程序调试很有用的名字。

__FILE__存放文件名的字符串字面值

__LINE__存放当前行号的整形字面值

__TIME__存放文件编译时间的字符串字面值

__DATE__存放文件编译日期的字符串字面值
