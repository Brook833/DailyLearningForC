2022.10.28



## 类的作用域
每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由对象、引用或指针使用成员访问运算符来访问。对于类类型成员则使用作用域运算符访问。不管哪种情况，跟在运算符之后的名字都必须是对应类的成员。

```c++
Screen::pos ht = 24, wd = 80; //使用Screen定义的pos类型
Screen scr(ht, wd, ' ');
Screen *p = &scr;
char c = scr.get(); //访问scr对象的get成员。
c = p->get(); //访问p所指对象的get成员
```

### 作用域和定义在类外部的成员
一个类就是一个作用域的事实就能很好的解释为什么当我们在类的外部定义成员函数时必须同时提供类名和函数名。在类的外部，成员的名字被隐藏起来了。

一旦遇到了类名，定义的剩余部分就是在类的作用域之内了，这里的剩余部分包括参数列表和函数体。我们可以直接使用类的其他成员而无须再次授权了。

例如，Window_mgr类的cleara成员，该函数的参数用到了Window_mgr类定义的一种类型：

```c++
void Window_mgr::clear(ScreenIndex i) {
    Screen &s = screens[i];
    s.contents = string(s.height * s.width, ' ');
}
```

因为编译器在处理参数列表之前已经明确了我们当前正位于Window_mgr类的作用域中，所以不必再专门说明ScreenIndex是Window_mgr类定义的。

另一方面，函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这是，返回类型必须之名他是哪个类的成员。例如，我们可能像Window_mgr类添加一个新的名为addScreen的函数，它负责向显示器添加一个新的屏幕。这个成员的返回类型是ScreenIndex,用户可以通过它定位到指定的Screen：

```c++
class Window_mgr {
public:
    //向窗口添加一个Screen,返回它的编号
    ScreenIndex addScreen(const Screen&);
    ...
};
//首先处理返回类型，之后我们才进入Window_mgr的作用域
Window_mgr::ScreenIndex Window_mgr::addScreen(const Screen &s) {
    screens.push_back(s);
    return screens.size() - 1;
}
```

因为返回类型出现在类名之前，所以事实上它是位于Window_mgr类的作用域之外的。在这种情况下，要想使用ScreenIndex作为返回类型，我们必须明确指定哪个类定义了它。

### 名字查找与类的作用域
在目前为止，我们编写的程序中，名字查找(寻找与所用名字最匹配的声明的过程)的过程比较直截了当：

首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。

如果没找到，继续查找外层作用域。

乳沟最终没有找到匹配的声明，则程序报错。

对于定义自类内部的成员函数来说，解析其中名字的方式与上述的查找规则有所区别，不过在当前的例子中体现的不太明显。类的定义分两步处理：

首先，编译成员的声明。

知道类全部可见后才编译函数体。

NOTE:
编译器处理完类种的全部声明后才会处理成员函数的定义。

按照这种两阶段的方式处理类可以简化类代码的组织方式。因为成员函数体知道整个类可见后才会被处理，所以它能使用类中定义的任何名字。相反，如果函数的定义和成员的声明被同时处理，那么我们将不得不在成员函数中只使用那些已经出现的名字。

### 用于类成员声明的名字查找
这种两阶段的处理方式只适用于成员函数中使用的名字。

声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续寻找。例如：

```c++
typedef double Money;
string bal;
class Account {
public:
    Money balance() { return bal; }
private:
    Money bal;
};
```

当编译器看到balance函数的声明语句时，它将在Account类的范围内寻找对Money的声明。编译器只考虑Account中在使用Money中出现的声明，因为没找到匹配的成员，所以编译器会接着到Account的外层作用域中查找。这个例子中，编译器会找到Money的typedef语句，该类型被用作balance函数的返回类型以及数据成员bal的类型。另一方面，balance在整个类可见后才被处理，因此，该函数的return语句返回名为bal的成员，而非外城作用域的string对象。

### 类型名要特殊处理
