2022.12.04



## 10.5.2算法形参模式
在任何其他算法分类之上，还有一组参数规范。理解这些参数规范对学习新算法很有帮助————通过理解参数的含义。你可以将注意力集中在算法所做的操作上。大多数算法具有如下4种形式之一:

```c++
alg(beg, end, other args);
alg(beg, end, dest, other args);
alg(beg, end, beg2, other args);
alg(beg, end, beg2, end2, otehr args);
```

其中alg是算法的名字，beg和end表示算法所操作的输入范围。几乎所有的算法都接受一个输入范围，是否有其他参数依赖于要执行的操作。这里列出了常见的一种————dest、beg2和end2，都是迭代器参数。顾名思义，如果用到了这些迭代器参数，它们分别承担指定目的位置和第二个范围的角色。除了这些迭代器参数，一些算法还接受额外的、非迭代器的特定参数。

### 接受单个目标迭代器的算法
dest参数是一个表示算法可以写入的目的位置的迭代器。算法假定(assume):按其需要写入数据，不管写入多少个元素都是安全的。

**WARNING: 向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据**

如果dest是一个直接指向容器的迭代器，那么算法将输出数据写到容器内已存在的元素内。更常见的一种情况是，dest被绑定到一个插入迭代器或是一个ostream_iterator。插入迭代器会将新元素添加到容器中，因而保证空间是足够的。ostream_iterator会将数据写入到一个输出流，同样不管要写入多少个元素都没有问题。

### 接受第二个输入序列的算法
接受单独的beg2或是接受beg2和end2的算法用这些迭代器表示第二个输入范围。这些算法通常使用第二个范围中的 元素与第一个输入范围结合来进行一些运算。

如果算法接受beg2和end2，这两个迭代器表示第二个范围。这类算法接受两个完整指定的范围:[beg, end)和[beg2, end)。

只接受单独的beg2(不接受end2)的算法将beg2作为第二个输入范围中的首元素。此范围的结束位置未指定，这些算法假定从beg2开始的范围与beg和end所表示的范围至少一样大。

**WARNING: 接受单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围至少一样大。**

## 10.5.3算法命名规范
除了参数规范，算法还遵循一套命名和重载规范。这些规范处理诸如:如何提供一个操作代替默认的<或==运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题。

### 一些算法使用重载形式传递一个谓词
接受谓词参数来代替<或==运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素:另一个版本接受一个额外谓词参数，来代替<或==:

```c++
unique(beg, end);  // 使用==运算符比较元素
unique(beg, end, comp);  // 使用comp比较元素
```

两个调用都重新整理给定序列，将相邻的重复元素删除。第一个调用使用元素类型的==运算符来检查重复元素；第二个则调用comp来确定两个元素是否相等。由于两个版本的函数在参数个数上不相等，因此具体应该调用哪个版本不会产生歧义。

### _if版本的算法
接受一个元素值的算法通常有另一个不同命的(不是重载的)版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的_if前缀:

```c++
find(beg, end, val);  // 查找输入范围中val第一次出现的位置
find_if(beg, end, pred);  // 查找第一个令pred为真的元素
```

这两个算法都在输入范围中查找特定元素第一次出现的位置。算法find查找一个指定值:算法find_if查找使得pred返回非零值的元素。

这两个算法提供了命名上差异的版本，而非重载版本，应为两个版本的算法都接受相同数目的参数，因此可能产生重载歧义，虽然很罕见，但为了避免任何可能的歧义，标准库选择提供不同名字的版本而不是重载。

### 区分拷贝元素的版本和不拷贝的版本
默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外的目的空间的算法都在名字后面附加一个_copy:

```c++
reverse(beg, end);  // 反转输入范围中元素的顺序
reverse_copy(beg, end, dest);  // 将元素按逆序拷贝到dest
```

一些算法同时提供_copy和_if版本。这些版本接受一个目的位置迭代器和一个谓词:

```c++
// 从v1中删除奇数元素
remove_if(v1.begin(), v1.end(), [](int i) { return i % 2; });

// 将偶数元素从v1拷贝到v2；v1不变:
remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [](int i) { return i % 2; });
```

两个算法都调用了lambda来确定元素是否为奇数。在第一个调用中，我们从输入序列中将奇数元素删除。在第二个调用中，我们将非奇数(即偶数)元素从输入范围拷贝到v2中。

