2022.11.25



## 10.3 定制操作
很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的<或==运算符来完成比较。标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。

例如，sort算法默认使用元素类型的<运算符。但可能我们希望的排序与<所定义的顺序不同，或是我们的序列可能保存的是未定义<运算符的元素类型(如Sales_data)。在这两种情况下，都需要重载sort的默认行为。

### 10.3.1 向算法传递函数
作为一个例子，假定希望在调用elimDups后打印vector的内容。此外还假定希望单词按照其长度排序，大小相同的再按字典序排列。为了按长度重排vector，我们将使用sort的第二个版本，此版本是重载过的，他接受第三个参数，此参数是一个谓词。

#### 谓词
谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：一元谓词(意味着它们只接受单一参数)和二元谓词(意味着它们有两个参数)。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。

接受一个二元谓词参数的sort版本用这个谓词代替<来比较元素。我们提供给sort的谓词必须满足将在11.2.2节中所介绍的条件。当前，我们只需知道，此操作必须在输入序列中所有可能的元素值定义一个一致的序。这样做会将元素按大小重新排序:

```c++
// 比较函数，用来按长度排序单词
bool isShorter(const string &s1, const string &s2) {
    return s1.size() < s2.size();
}
// 按长度由短至长排序words
sort(words.begin(), words.end(), isShorter);
```

如果words包含的数据与10.2.3节中一样，此调用会将words重排，使得所有长度为3的单词排在长度为4的单词之前，然后是长度为5的单词，依次类推。

### 排序算法
在我们将words按大小重排的同时，还希望具有相同长度的元素按字典序排序。为了保持相同长度的单词按字典序排序，可以使用stable_sort算法。这种稳定排序算法维持相等元素的原有顺序。

通常情况下，我们不关心有序序列中想等元素的相对顺序，它们毕竟是相等的。但是，在本例中，我们定义的"相等"关系表示"具有相同长度"。而具有相同长度的元素，如果看其内容，其实还是各不相同的。通过调用stable_sort，可以保持等长元素间的字典序:

```c++
elimDups(words);  // 将words按字典序重排，并消除重复单词
// 按长度重新排序，长度相同的单词维持字典序
statble_sort(words.begin(), words.end(), isShorter);
for(const auto &s : words) // 无需拷贝字符串
{
    cout << s << " ";  // 打印每个元素
}
cout << endl;
```
