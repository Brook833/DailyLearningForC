2022.10.22



### 在类的外部定义构造函数
与其他几个构造函数不同，以istream为参数的构造函数需要执行一些实际的操作。在它的函数体内，调用了read函数以给数据成员赋初值：
```c++
Sales_data::Sales_data(std::istream &is) {
    read(is, *this); //read函数的作用是从is中读取一i套交易信息然后存入this对象中。
}
```
构造函数没有返回类型，所以上述定义从我们指定的函数名字开始。和其他成员函数一样，当我们在类的外部定义构造函数时，必须指明该构造函数是哪个类的成员。因此，Sales_data::Sales_data的含义是我们定义Sales_data类的成员，它的名字是Sales_data。又因为该成员的名字和类名相同，所以它是一个构造函数。

这个构造函数没有构造函数初始值列表，或者讲的更准确一点，它的构造函数初始值列表是空的。尽管构造函数初始值列表是空的，但是由于执行了构造函数体，所以对象的成员仍然能被初始化。

没有出现在构造函数初始值列表中的成员将通过相应的类内初始值初始化，或者执行默认初始化。对于Sales_data来说，这意味着一旦函数开始执行，则bookNo将被初始化成空string对象，而units_sold和revenue是0.

为了更好理解调用函数read的意义，要特别注意read的第二个参数是一个Sales_data对象的引用，使用this来把对象当成一个整体访问，而非直接访问对象的某个成员。因此在此例中，我们使用*this将“this”对象作为实参传递给read函数

## 拷贝、赋值和析构
除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。对象在几种情况下会被拷贝，如我们初始化变量以及以值的方式传递或返回一个对象等。当我们使用了赋值运算符时会发生对象的赋值操作。当对象不在存在时执行销毁的操作，比如一个局部对象在创建它的块结束时会被销毁，当vector对象销毁时，存储在其中的对象也会被销毁。

如果我们不主动定义这些操作，则编译器将替我们合成它们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝，赋值和销毁操作。

当编译器执行如下赋值语句时：
```c++
total = trans; //处理一下本书的信息
```
它的行为和下面的代码相同：
```c++
total.bookNo = tarns.bookNo;
total.units_sold = trans.units_sold;
total.revenue = trans.revenue;
```

### 某些类不能依赖于合成的版本
尽管编译器能替我们合成拷贝、赋值、和销毁的操作，但时必须要清楚的一点是，对于某些类来说合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。比如管理动态内存的类通常不能依赖于上述操作的合成版本。

不过值得注意的是，很多需要动态内存的类能(而且应该)使用vector对象或者string对象管理必要的存储空间。使用vector或者string的类能避免分配和释放内存带来的复杂性。

进一步讲，如果类包含vector或者string成员，则其拷贝、赋值和销毁的合成版本能够正常工作。当我们对含有vector成员的对象执行拷贝或者赋值操作时，vector类会设法拷贝或者赋值成员中的元素。当这样的对象被销毁时，将销毁vector对象，也就是依次销毁vector中的每一个元素。这一点与string是非常类似的。