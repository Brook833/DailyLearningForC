2022.11.16



## 9.3.6 容器操作可能使迭代器失效
向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器都是一种严重的程序设计错误，很可能引起与使用未初始化指针一样的问题。

向容器添加元素后：
> + 如果容器使vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效
> + 对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。
> + 对于list和forward_list，指向容器的迭代器(包括尾后迭代器和首前迭代器)、指针和引用仍有效

当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，这应该不会让人惊讶。毕竟，这些元素已经被销毁了。

当我们删除一个元素后：
> + 对于list和forward_list，指向容器其他位置的迭代器(包括尾后迭代器和首前迭代器)、引用和指针仍有效。
> + 对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是首元素，这些也不会受影响。
> + 对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。注意：当我们删除元素时，尾后迭代器总是会失效。

**WARNING: 使用失效的迭代器、指针或引用是严重的运行时错误**

==建议: 管理迭代器
当你使用迭代器(或指向容器元素的引用或指针)时，最小化要求迭代器必须保持有效的程序片段是一个好的方法。
由于向迭代器添加元素和从迭代器删除元素的代码可能使迭代器失效，因此必须保证每次改变容器的操作之后都正确的重新定位迭代器。这个建议对vector、string和deque尤其重要==

### 编写改变容器的循环程序
添加/删除vector、string或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须保证每个循环步中都更新迭代器、引用或指针。如果循环中调用的是insert或erase，那么更新迭代器很容器。这些操作都返回迭代器，我们可以用来更新：

```c++
// 傻瓜寻韩，删除偶数元素，复制每个奇数元素
vector<int> vi {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
auto iter = vi.begin();  // 调用begin而不是cbegin，因为我们要改变vi
while(iter != vi.end) {
    if (*iter % 2) {
        iter = vi.insert(iter, *iter);  // 复制当前元素
        iter += 2;  // 向前移动迭代器，跳过当前元素以及插入到它之前的元素
    } else {
        iter = vi.erase(iter);  // 删除偶数元素
        // 不应向前移动迭代器，iter指向我们删除元素之后的元素
    }
}
```

此程序删除vector中的偶数值元素，并复制每个奇数值元素。我们在调用insert和erase后都更新迭代器，因为两者都会使迭代器失效。

在调用insert后，不必递增迭代器，因为erase返回的迭代器已经指向序列中下一个元素。调用insert后，需递增迭代器两次。记住，insert在给定位置之前插入元素，位于我们正在处理的元素之前。我们将迭代器递增两次，恰好越过了新添加的元素和正在处理的元素，指向下一个未处理的元素。

### 不要保存end返回的迭代器
当我们添加/删除vector或string的元素后，或在deque中首元素之外任何位置添加/删除元素后，原来end返回的迭代器总是会失效。因此，添加或删除元素的循环程序必须反复调用end，而不能在循环之前保存end返回的迭代器一直当做容器末尾使用。通常C++的标准库的实现中end()操作都很快，部分就是因为这个原因。

例如，考虑这样一个循环，它处理容器中的每个元素，在其后添加一个新元素。我们希望循环能跳过新添加的元素，只处理原有元素。在每步循环之后，我们将定位迭代器，使其指向下一个原有元素。如果我们试图”优化“这个循环，再循环之前保存end()返回的迭代器，一直用作容器末尾，就会导致一场灾难：

```c++
// 灾难：此循环的行为是未定义的
auto begin = v.begin(), end = v.end();  // 保存尾迭代器是一个坏主意
while (begin != end) {
    // 做一些处理
    // 插入新值；对begin重新赋值否则他就会失效
    ++begin;  // 向前移动begin，因为我们想在此元素之后插入元素
    begin = v.insert(begin, 42);  // 插入新值
    ++begin;  // 向前移动begin跳过我们刚刚加入的元素
}
```

此代码的行为是未定义的。在很多标准库实现上，此代码会导致无线循环。问题在于我们将end操作返回的迭代器保存在一个名为end的局部变量中。在循环体中，我们向容器中添加了一个元素，这个操作使保存在end中的迭代器失效了。这个迭代器不在指向v中任何元素，或是v中尾元素之后的位置。

**Tip: 如果在一个寻汉中插入/删除deque、string或vector中的元素，不要缓存end返回的迭代器**

必须在每次插入操作后重新调用end(),而不能在循环开始前保存它返回的迭代器：

```c++
// 更安全的方法：在每个循环步添加/删除元素后都重新计算end
while (begin != v.end()) {
    //做一些处理
    ++begin;  // 向前移动begin，因为我们想在此元素之后插入元素
    begin = v.insert(begin, 42);  // 插入新制
    ++begin;  // 向前移动begin，跳过我们刚刚加入的元素
}
```
