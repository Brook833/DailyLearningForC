2022.11.16



## 9.3.6 容器操作可能使迭代器失效
向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器都是一种严重的程序设计错误，很可能引起与使用未初始化指针一样的问题。

向容器添加元素后：
> + 如果容器使vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效
> + 对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。
> + 对于list和forward_list，指向容器的迭代器(包括尾后迭代器和首前迭代器)、指针和引用仍有效

当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，这应该不会让人惊讶。毕竟，这些元素已经被销毁了。

当我们删除一个元素后：
> + 对于list和forward_list，指向容器其他位置的迭代器(包括尾后迭代器和首前迭代器)、引用和指针仍有效。
> + 对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是首元素，这些也不会受影响。
> + 对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。注意：当我们删除元素时，尾后迭代器总是会失效。

**WARNING: 使用失效的迭代器、指针或引用是严重的运行时错误**

==建议: 管理迭代器
当你使用迭代器(或指向容器元素的引用或指针)时，最小化要求迭代器必须保持有效的程序片段是一个好的方法。
由于向迭代器添加元素和从迭代器删除元素的代码可能使迭代器失效，因此必须保证每次改变容器的操作之后都正确的重新定位迭代器。这个建议对vector、string和deque尤其重要==

### 编写改变容器的循环程序
添加/删除vector、string或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须保证每个循环步中都更新迭代器、引用或指针。如果循环中调用的是insert或erase，那么更新迭代器很容器。这些操作都返回迭代器，我们可以用来更新：

```c++
// 傻瓜寻韩，删除偶数元素，复制每个奇数元素
vector<int> vi {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
auto iter = vi.begin();  // 调用begin而不是cbegin，因为我们要改变vi
while(iter != vi.end) {
    if (*iter % 2) {
        iter = vi.insert(iter, *iter);  // 复制当前元素
        iter += 2;  // 向前移动迭代器，跳过当前元素以及插入到它之前的元素
    } else {
        iter = vi.erase(iter);  // 删除偶数元素
        // 不应向前移动迭代器，iter指向我们删除元素之后的元素
    }
}
```

此程序删除vector中的偶数值元素，并复制每个奇数值元素。我们在调用insert和erase后都更新迭代器，因为两者都会使迭代器失效。

在调用insert后，不必递增迭代器，因为erase返回的迭代器已经指向序列中下一个元素。调用insert后，需递增迭代器两次。记住，insert在给定位置之前插入元素，位于我们正在处理的元素之前。我们将迭代器递增两次，恰好越过了新添加的元素和正在处理的元素，指向下一个未处理的元素。

### 不要保存end返回的迭代器
当我们添加/删除vector或string的元素后，或在deque中首元素之外任何位置添加/删除元素后，原来end返回的迭代器总是会失效。因此，添加或删除元素的循环程序必须反复调用end，而不能在循环之前保存end返回的迭代器一直当做容器末尾使用。通常C++的标准库的实现中end()操作都很快，部分就是因为这个原因。

例如，考虑这样一个循环，它处理容器中的每个元素，在其后添加一个新元素。我们希望循环能跳过新添加的元素，只处理原有元素。在每步循环之后，我们将定位迭代器，使其指向下一个原有元素。如果我们试图”优化“这个循环，再循环之前保存end()返回的迭代器，一直用作容器末尾，就会导致一场灾难：

```c++
// 灾难：此循环的行为是未定义的
auto begin = v.begin(), end = v.end();  // 保存尾迭代器是一个坏主意
while (begin != end) {
    // 做一些处理
    // 插入新值；对begin重新赋值否则他就会失效
    ++begin;  // 向前移动begin，因为我们想在此元素之后插入元素
    begin = v.insert(begin, 42);  // 插入新值
    ++begin;  // 向前移动begin跳过我们刚刚加入的元素
}
```

此代码的行为是未定义的。在很多标准库实现上，此代码会导致无线循环。问题在于我们将end操作返回的迭代器保存在一个名为end的局部变量中。在循环体中，我们向容器中添加了一个元素，这个操作使保存在end中的迭代器失效了。这个迭代器不在指向v中任何元素，或是v中尾元素之后的位置。

**Tip: 如果在一个寻汉中插入/删除deque、string或vector中的元素，不要缓存end返回的迭代器**

必须在每次插入操作后重新调用end(),而不能在循环开始前保存它返回的迭代器：

```c++
// 更安全的方法：在每个循环步添加/删除元素后都重新计算end
while (begin != v.end()) {
    //做一些处理
    ++begin;  // 向前移动begin，因为我们想在此元素之后插入元素
    begin = v.insert(begin, 42);  // 插入新制
    ++begin;  // 向前移动begin，跳过我们刚刚加入的元素
}
```

# 9.4 vector对象是如何增长的
为了支持快速随机访问，vector将元素连续存储，每个元素紧挨着前一个元素存储。通常情况下，我们不必关心一个标准库类型是如何实现的，而只需关心它如何使用。然而，对于vector和string，其部分实现渗透到了接口中。

假定容器中元素是连续存储的，且容器大小是可变的，考虑向vector或string中添加元素会发生什么；如果没有空间容纳新元素，容器不可能简单地将他添加到内存中其他位置————因为元素必须连续存储。容器必须分配新的内存空间来保存已有元素和新元素，将已有元素从旧位置移动到新空间中，然后添加新元素、释放旧存储空间。如果我们每添加一个旧元素，vector就执行一次这样的内存分配和释放操作，性能会慢到不可接受。

为了避免这种代价，标准库实现者采用了可以减少容器空间重新分配次数的策略。当不得不获取新的内存空间，vector和string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。这样，就不需要每次添加元素都重新分配容器的内存空间了。

这种分配策略比每次提娜佳新元素时都重新分配容器内村空间的策略要高效的多。其实际性能也i凹陷的足够好————虽然vector在每次重新分配内存空间时都要移动所有元素，但是用此策略后，其扩张操作通常比list和deque还要快。

### 管理容器的成员函数
如表9.10所示，vector和string类型提供了一些成员函数，允许我们与他的实现中内存分配部分互动。capacity操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素。reserve操作允许我们通知容器它应该准备保存多少个元素。

| **表9.10: 容器大小管理操作** |  |
|:- |:- |
| shrink_to_fit只适用于vector、string和deque |  |
| capacity和reserve只适用于vector和string |  |
| c.shrink_to_fit() | 请将capacity()减少为与size()相同大小 |
| c.capacity() | 不重新分配内存空间的话，c可以保存多少元素 |
| c.reserve(n) | 分配至少能容纳n个元素的内存空间 |

**Note: reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间**

只有当需要的内存空间超过当前容量时，reserve迪奥用才会改变vector的容量。如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间(可能更大)。

如果需求大小小于或等于当前容量，reserve什么也不做，特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用reserve之后，capacity将会大于或等于传递给reserve的参数。

这样，调用reserve永远也不会减少容器占用的内存空间。类似的，resize成员函数只改变容器中元素的数目，而不是容器的容量。我们同样不能使用resize来减少容器预留的内存空间。

在新标准库中，我们可以调用shrink_to_fit来要求deque、vectro和string退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，具体的实现可以选择忽略此请求。也就是说，调用shrink_to_fit也并不保证一定退回内存空间。