2022.11.04



## 9.3.2 访问元素
表9.6列出了我们可以用来在顺序容器中访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。

包括array在内的每个顺序容器都有一个front成员函数，而除forward_list之外的所有顺序容器都有一个back成员函数。这两个操作分别返回收元素和微元素的引用：

```c++
//在姐饮用一个迭代器或调用front或back之前检查是否有元素
if (!c.empty()) {
    // val 和 val2 是c中第一个元素值的拷贝
    auto val = *c.begin(),  val2 = c.front();
    // val3 和 val4 是c中最后一个元素值的拷贝
    auto last = c.end();
    auto val3 = *(--last);  // 不能递减froward_list迭代器
    auto val4 = c.back();  // forward_list不支持
}
```

此程序用两种不同方式来获取c中的首元素和尾元素的引用。直接的方法是调用front和back。而间接的方法是通过解引用begin返回的迭代器来获得首元素的引用，以及通过递减然后解引用end返回的迭代器来获得尾元素的引用。

这个程序有两点值注意: 迭代器end指向的是容器微元素之后的(不存在的)元素。为了获取尾元素，必须首先递减此迭代器。另一个重要之处是，在调用front和back(或解引用begin和end返回的迭代器)之前，要确保c非空。如果容器为空，if中操作的行为将是未定义的。

| **表9.6: 在顺序容器中访问元素的操作** |  |
|:- |:- |
| at和下标操作只适用于string、vector、deque和array |  |
| back不适用于forward_list |  |
| c.back() | 返回c中尾元素的引用。若c为空，函数行为未定义 |
| c.front() | 返回c中首元素的引用。若c为空，函数行为未定义 |
| c[n] | 返回c中下标为n的元素的引用，n是一个无符号整数。若n>=c.size(),则函数行为未定义 |
| c.at(n) | 返回下标为n的元素的引用。如果下标越界，则抛出一out_of_range异常 |

**WARNING: 对一个空容器调用front和back，就像使用一个越界的下标一样，是一种严重的程序设计错误**

### 访问成员函数返回的是引用
在容器中访问元素的成员函数(即，front、back、下标和at)返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值:

```c++
if (!c.empty()) {
    c.front() = 42;  // 将42赋予c中第一个元素
    auto &v = c.back();  // 获取指向最后一个元素的引用
    v = 1024;  // 改变c中的最后一个元素
    auto v2 = c.back();  // v2不是一个引用，他是c.back()的一个拷贝
    v2 = 0;  // 为改变c中的最后一个元素
}
```

与往常一样，如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。

### 下标操作和安全的随机访问
提供快速随机访问的容器(string、vector、deque和array)也都提供下标运算符。就像我们看到的那样，下标运算符接受一个下标参数，返回容器中该位置的元素的引用。给定下标必须"在范围内"(即，大于等于0，且小于容器的大小)。保证下标有效是程序员的责任，下标运算符并不检查是否早合法范围内。使用越界的下标是一种严重的程序设计错误，而且编译器并不检查这种错误。

如果我们希望确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，但如果下标越界，at会爆出一个out_of_range异常:

```c++
vector<string> svec;  // 空vector
cout << svec[0];  // 运行时错误，svec中没有元素
cout << svec.at[0];  // 抛出一个out_of_range异常
```