2022.11.04



## 9.3.2 访问元素
表9.6列出了我们可以用来在顺序容器中访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。

包括array在内的每个顺序容器都有一个front成员函数，而除forward_list之外的所有顺序容器都有一个back成员函数。这两个操作分别返回收元素和微元素的引用：

```c++
//在姐饮用一个迭代器或调用front或back之前检查是否有元素
if (!c.empty()) {
    // val 和 val2 是c中第一个元素值的拷贝
    auto val = *c.begin(),  val2 = c.front();
    // val3 和 val4 是c中最后一个元素值的拷贝
    auto last = c.end();
    auto val3 = *(--last);  // 不能递减froward_list迭代器
    auto val4 = c.back();  // forward_list不支持
}
```

此程序用两种不同方式来获取c中的首元素和尾元素的引用。直接的方法是调用front和back。而间接的方法是通过解引用begin返回的迭代器来获得首元素的引用，以及通过递减然后解引用end返回的迭代器来获得尾元素的引用。

这个程序有两点值注意: 迭代器end指向的是容器微元素之后的(不存在的)元素。为了获取尾元素，必须首先递减此迭代器。另一个重要之处是，在调用front和back(或解引用begin和end返回的迭代器)之前，要确保c非空。如果容器为空，if中操作的行为将是未定义的。

| **表9.6: 在顺序容器中访问元素的操作** |  |
|:- |:- |
| at和下标操作只适用于string、vector、deque和array |  |
| back不适用于forward_list |  |
| c.back() | 返回c中尾元素的引用。若c为空，函数行为未定义 |
| c.front() | 返回c中首元素的引用。若c为空，函数行为未定义 |
| c[n] | 返回c中下标为n的元素的引用，n是一个无符号整数。若n>=c.size(),则函数行为未定义 |
| c.at(n) | 返回下标为n的元素的引用。如果下标越界，则抛出一out_of_range异常 |

**WARNING: 对一个空容器调用front和back，就像使用一个越界的下标一样，是一种严重的程序设计错误**

### 访问成员函数返回的是引用
在容器中访问元素的成员函数(即，front、back、下标和at)返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值:

```c++
if (!c.empty()) {
    c.front() = 42;  // 将42赋予c中第一个元素
    auto &v = c.back();  // 获取指向最后一个元素的引用
    v = 1024;  // 改变c中的最后一个元素
    auto v2 = c.back();  // v2不是一个引用，他是c.back()的一个拷贝
    v2 = 0;  // 为改变c中的最后一个元素
}
```

与往常一样，如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。

### 下标操作和安全的随机访问
提供快速随机访问的容器(string、vector、deque和array)也都提供下标运算符。就像我们看到的那样，下标运算符接受一个下标参数，返回容器中该位置的元素的引用。给定下标必须"在范围内"(即，大于等于0，且小于容器的大小)。保证下标有效是程序员的责任，下标运算符并不检查是否早合法范围内。使用越界的下标是一种严重的程序设计错误，而且编译器并不检查这种错误。

如果我们希望确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，但如果下标越界，at会爆出一个out_of_range异常:

```c++
vector<string> svec;  // 空vector
cout << svec[0];  // 运行时错误，svec中没有元素
cout << svec.at[0];  // 抛出一个out_of_range异常
```

## 9.3.3 删除元素
与添加元素的多种方式类似，(非array)容器也有多种删除元素的方式。表9.7列出了这些成员函数。

| **表9.7: 顺序容器的删除操作** |  |
| 这些操作会改变容器的大小，所以不适用于array |  |
| forward_list有特殊版本的erase |  |
| forward_list不支持pop_back;vector和string不支持pop_front |  |
| c.pop_back() | 删除c中尾元素。若c为空，则函数行为未定义。函数返回void |
| c.pop_fornt() | 删除c中首元素。若c为空，则函数行为未定义。函数返回void |
| c.erase(p) | 删除迭代器p所指定的元素，返回一个指向被删元素之后的元素迭代器，若p直线为元素，则返回尾后迭代器。若p是尾后迭代器，则函数行为未定义 |
| c.erase(b,e) | 删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被删元素之后的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器 |
| c.clear() | 删除c中的所有元素。返回void |

**WARNING: 删除deque中除首尾位置之外的任何元素都会是所有迭代器、引用和指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。**

**WARNING: 删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它是存在的。**

### pop_front和pop_back成员函数
pop_fornt和pop_back成员函数分别删除首元素和尾元素。与vector和string不支持push_front一样，这些类型也不支持pop_front。类似的forward_list也不支持pop_back。与元素访问成员函数类似，不能对一个空容器执行弹出操作。

这些操作返回void。如果你需要弹出的元素的值，就必须在弹出操作前保存它：

```c++
while (!ilist.empty()) {
    process(ilist.front());  // 对ilist的首元素进行一些处理
    ilist.pop_fornt();  // 完成处理后删除首元素
}
```

### 从容器内部删除一个元素
成员函数erase从容器中指定位置删除元素。我们可以删除有一个迭代器指定的单个元素，也可以删除由一对元素指定的范围内的所有元素。两种形式的erase都返回只想删除的元素之后位置的迭代器。即，若j是i之后的元素，那么erase(i)将返回指向j的迭代器。

例如，下面的循环删除一个list中的所有奇数元素：

```c++
list<int> 1st = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
auto it = 1st.begin();
while (it != 1st.end())  {
    if (*it % 2) {
        it = 1st.erase(it);
    } else {
        it++;
    }
}
```

### 删除多个元素
接受一对迭代器的erase版本允许我们删除一个范围内的元素：

```c++
// 接受两个迭代器表示的范围内的元素
// 返回指向最后一个被删元素之后位置的迭代器
elem1 = slist.erase(elem1, elem2);  // 调用后，elem1 == elem2
```

迭代器elem1指向我们要删除的第一个元素，elem2指向我们要删除的最后一个元素之后的位置。

为了删除一个容器中的所有元素，我们既可以调用clear，也可以用begin和end获得的迭代器作为参数调用erase;

```c++
slist.clear();  // 删除容器中所有元素
slist.erase(slist.begin(), slist.end());  // 删除容器中所有元素
```
