## 12.3 使用标准库:文本查询程序
我们将实现一个简单的文本查询程序，作为标注库相关内容学习的总结。我们的程序允许用户在一个给定文件中查询单词。查询结果是单词在文件中出现的次数及其所在行的列表。如果一个单词在一行中出现多次，此行只列出一次。行会按照升序输出————即，第7行会在第9行之前显示，以此类推。

例如，我们呢可能读入一个包含本章内容(指英文版中的文本)的文件，在其中寻找单词element。输出结果的前几行应该是这样的:

```c++
element occurs 112 times
    (line 36) A set element contains only a key;
    (line 158) operator creates a new element
```

接下来还有大约100行，都是单词element出现的位置

### 12.3.1 文本查询程序设计
开始一个程序的设计的一种好方法是列出程序的操作。了解需要哪些操作会帮助我们分析出需要什么样的数据结构。从需求入手，我们的文本查询程序需要完成如下任务:
> + 当程序读取输入文件时，他必须记住单词出现的每一行。因此，程序需要逐行读取输入文件，并将每一行分解为独立的单词。
> + 当程序输出时
    >> + 它必须能提取每个单词所关联的行号
    >> + 行号必须按升序出现且无重复
    >> + 它必须能打印给定行号中的文本

利用多种标准库设施，我们可以很漂亮的实现这些要求:
> + 我们将使用一个vector<string>来保存整个输入文件的一份拷贝。输入文件中的每行保存为vector中的一个元素。当需要打印一行时，可以用行号作为下标来提取行文本。
> + 我们使用一个istringstream来将每行分解为单词。
> + 我们使用一个set来保存每个单词在输入文本中出现的行号。这保证了每行只出现一次且行号按升序保存。
> + 我们使用一个map来将每个单词与它出现的行号set关联起来。这样我们就可以方便的提取任意单词的set。

我们的解决方案还使用了shared_ptr，原因稍后进行解释。

#### 数据结构
虽然我们可以用vector，set和map来直接编写文本查询程序，但如果定义一个更为抽象的解决方案，会更为有效。我们将从定义一个输入文件的类开始，这会令文件查询更为容易。我们将这个类命名为TextQuery，它包含一个vector和一个map。vector用来保存输入文件的文本，map用来关联每个单词和它出现的行号的set。这个类将会有一个用来读取给定输入文件的构造函数和一个执行查询的操作。

查询操作要完成的任务非常简单:查找map成员，检查给定单词是否出现。设计这个函数的难点是确定应该返回什么内容。一旦找到了一个单词，我们需要知道他出现了多少次、它出现的行号以及每行的文本。

返回所有这些内容的最简单的方法是定义另一个类，可以命名为QueryResult，来保存查询结果。这个类有一个print函数，完成结果打印工作。

#### 在类之间共享数据
我们的QueryResult类要表达查询的结果。这些结果包括与给定单词关联的行号的set和这些行对应的文本。这些数据都保存在TextQuery类型的对象中。

由于QueryResult所需要的数据都保存在一个TextQuery对象中，我们就必须确定如何访问它们。我闷可以拷贝行号的set，但这样做可能很耗时。而且，我们当不希望拷贝vector，因为这可能会引起整个文件的拷贝，而目标只不过是为了打印文件的一小部分而已。

通过返回指向TextQuery对象内部的迭代器(或指针)，我们可以避免拷贝操作。但是，这种方法开启了一个陷阱:如果TextQuery对象在对应的QueryResult对象之前被销毁，会发生什么？在此情况下，QueryResult就将引用一个不再存在的对象中的数据。

对于QueryResult对象和对应的TextQuery对象的生存期应该同步这一观察结果，其实已经暗示了问题的解决方案。考虑到这两个类概念上“共享”了数据，可以使用shared_ptr来反映数据中的这种共享关系。

#### 使用TextQuery类
当我们设计一个类时，在真正实现成员之前先编写程序使用这个类，是一种非常有用的方法。通过这种方法，可以看到类是否具有我们所需要的操作。例如，下面的程序使用了TextQuery和QuertResult类。这个函数接受一个指向要处理的文件的ifstream，并与用户交互，打印给定单词的查询结果:

```c++
void runQueries(ifstream &infile) {
    // infile 是一个ifstream,指向我们要处理的文件
    TextQuert tq(infile);  // 保存文件并建立查询map
    // 与用户交互:提示用户输入
}