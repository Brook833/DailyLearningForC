## 12.2 动态数组
new和delete运算符一次分配/释放一个对象，但某些应用需要一次为很多对象分配内存的功能。例如，vector和string都是在连续内存中保存他们的元素，因此，当容器需要重新分配内存时，必须一次性为很多元素分配内存。

为了支持这种需求，C++语言和标准提供了两种一次分配一个对象数组的方法。C++语言定义了另一种new表达式语法，可以分配并初始化一个对象数组。标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。

很多(可能是大多数)应用都没有直接访问动态数组的需求。当一个应用需要可变数量的对象时，我们在StrBlob中采用的方法几乎总是更简单、更快速并且更安全的————即，使用vector(或其他标准库容器)。使用标准库容器的优势在新标准下更为显著。在支持新标准的标准库中，容器操作比之前的版本要快速的多。

**Best practices:大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能由更好的性能。**

如前所述，使用容器的类可以使用默认版本的拷贝、赋值和析构操作。分配动态数组的类则必须定义自己版本的操作，在拷贝、赋值以及销毁对象时管理所关联的内存。

### 12.2.1 new和数组
为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目。在下例中，new分配要求数量的对象并(假定分配成功后)返回指向第一个对象的指针:

```c++
// 调用get_size确定分配多少个int
int *pia = new int[get_size()];  // pia指向第一个int
```

方括号中的大小必须是整形，但不必是常量。

也可以用一个表示数组类型的类型别名来分配一个数组，这样，new表达式中就不需要方括号了:

```c++
typedef int arrT[42];  // arrT表示42个int的数组类型
int *p = new arrT;  // 分配一个42个int的数组;p指向第一个int
```

在本例中，new分配一个int数组，并返回指向第一个int的指针。即使这段代码中没有方括号，编译器执行这个表达式时还是会用new[]。即编译器执行如下形式:

```c++
int *p = new int[42];
```

#### 分配一个数组会得到一个元素类型的指针
虽然我们通常称new T[ ]分配的内存为"动态数组",但这种叫法某种程度上有些误导。当用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。即使我们使用类型别名定义了一个数组类型，new也不会分配一个数组类型的对象。在上例中，我们正在分配一个数组的事实甚至都是不可见的————连[num]都没有。new返回的是一个元素类型的指针。

由于分配的内存并不是一个数组类型，因此不能对动态数组调用begin或end。这些函数使用数组维度来返回指向首元素和尾后元素的指针。处于相同的原因，也不能用范围for语句来处理(所谓的)动态数组中的元素。

**WARNING:要记住我们所说的动态数组并不是数组类型**

#### 初始化动态分配对象的数组
默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号。

```c++
int *pia = new int[10];  // 10个未初始化的int
int *pia2 = new int[10]();  // 10个值初始化为0的int
int *psa = new string[10];  // 10个空string
int *psa2 = new string[10]();  // 10个空string
```

在新标准中，我们还可以提供一个元素初始化器的花括号列表:

```c++
int *pia3 = new int[10]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};  // 10个int分别用列表中对应的初始化器初始化
string *psa3 = new string[10] {"a", "an", "the", string{3,'x'}};
```

与内置数组对象的列表初始化一样，初始化器会用来初始化动态数组中开始部分的元素。如果初始化器数目小于元素数目，剩余元素将进行值初始化。如果初始化器数目大于元素数目，则new表达式失败，不会分配任何内存。在本例中，new会抛出一个类型为bad_array_new_length的异常。类似bad_alloc，此类型定义在头文件new中。

虽然我们用空括号对数组中的元素进行值初始化，但不能在括号中给出初始化器，这意味着不能用auto分配数组。

#### 动态分配一个空数组是合法的
可以用任意表达式来确定要分配的对象的数目:

```c++
size_t n = get_size();  // get_size返回需要的元素的数目
int *p = new int[n];  // 分配数组保存元素
for (int *q = p; q != p + n; ++q) {
    /* 处理数组 */;
}
```

这产生了一个有意思的问题，如果get_size返回0，会发生什么？答案是代码仍能正常工作。虽然我们不能创建一个大小为0的静态数组对象，但当n等于0时，调用new[n]是合法的:

```c++
char arr[0];  // 错误，不能定义长度为0的数组
char *cp = new char[0];  // 正确，但cp不能解引用
```

当我们用new分配一个大小为0的数组时，new返回一个合法的非空指针。此指针保证与new返回的其他任何指针都不相同。对于零长度的数组来说，此指针就像尾后指针一样，我们可以向使用尾后迭代器一样使用这个指针。可以用此指针进行比较操作，就像上面循环代码中那种。可以向此指针加上(或从此指针减去)0，也可以从此指针减去自身从而得到0.但此指针不能解引用————毕竟它不指向任何元素。

在我们假想的循环中，若get_size返回0，则n也是0，new会分配0个对象。for循环中的条件会失败(p等于q+n,因为n等于0)。因此，循环体不会被执行。

#### 释放动态数组
为了释放动态数组，我们使用一种特殊形式的delete————在指针前加上一个空方括号对:

```c++
delete p;  // p必须指向一个动态分配的对象或为空
delete [] pa;  // pa必须指向一个动态分配的数组或为空
```

第二条语句销毁pa指向的数组中的元素，并释放对应的内存。数组中的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，以此类推。

当我们释放一个指向数组的指针时，空方括号对是必须的:它指示编译器此指针指向一个对象数组的第一个元素。如果我们在delete一个指向数组的指针时忽略了方括号(或者在delete一个指向单一对象的指针时使用了方括号)，其行为是未定义的。

回忆一下，当我们使用一个类型别名来定义一个数组类型时，在new表达式中不使用[]。即使是这样，在释放一个数组指针时也必须使用方括号:

```c++
typedef int arrT[42];  // arrT是42个int的数组的类型别名
int *p = new arrT;  // 分配一个42个int的数组；p指向第一个元素
delete [] p;  // 方括号是必需的，因为我们当初分配的是一个数组。
```

不管外表如何，p指向一个对象数组的首元素，而不是一个类型为arrT的单一对象。因此，在释放p时我们必须使用[]。

**WARNING:如果我们在delete一个数组指针时忘记了方括号，或者在delete一个单一对象的指针时使用了方括号，编译器很可能不会给出警告。我们的程序可能在执行过程中在没有任何警告的情况下行为异常。**