到目前为止，我们编写的程序中所使用的对象都有着严格定义的生存期。全局对象在程序启动时自动分配，在程序结束时销毁。对于局部自动对象，当我们进入其定义所在的程序块时创建，在离开块时销毁。局部static对象在第一次使用前分配，在程序结束时销毁。

除了自动和static对象外，C++还支持动态分配对象。动态分配对象的生存期与它们在哪里创建是无关的，只有当显式的被释放时，这些对象才会销毁。

动态对象的正确释放被证明是编程中极其容易出错的地方。为了更安全的使用动态对象，标准库定义了两个智能指针类型来管理动态分配的对象。当一个对象应该被释放时，指向它的智能指针可以确保自动的释放它。

我们的程序到目前为止只是用过静态内存或栈内存。静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。

除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间(free store)或堆。程序用堆来存储动态分配(dynamically allocate)的对象————即，那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们呢的代码必须显式的销毁它们。

**WARNING: 虽然使用动态内存有时是必要的，但众所周知，正确的管理动态内存是非常棘手的**

## 12.1动态内存与智能指针
在C++中，动态内存的管理是通过一堆运算符来完成的:new，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择堆对象进行初始化;delete,接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。

动态内存的使用很容易出问题，因为确保在正确的时间释放内存是极其困难的。有时我们会忘记释放内存，在这种情况下就会产生内存泄露；有时在尚有指针引用内存的情况下我们就释放了它，在这种情况下就会产生引用非法内存地址的指针。

为了更容易(同时也更安全)的使用动态内存，新的标准库提供了两种智能指针(smart pointer)类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式:

shared_ptr允许多个指针指向同一个对象；

unique_ptr则"独占"所指向的对象。

标准库还定义了一种名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在memory头文件中。

### 12.1.1 shared_ptr类
类似vector，智能指针也是模板。因此，当我们创建一个智能指针时，必须提供额外的信息————指针可以指向的类型。与vector一样，我们再尖括号内给出类型，之后是所定义的这种智能指针的名字:

```c++
shared_ptr<string> p1;  // shared_ptr，可以指向string
shared_ptr<list<int>> p2;  // shared_ptr,可以指向int的list
```

默认初始化的智能指针中保存着一个空指针。

智能指针的使用方式与普通指针类似。解引用一个智能指针返回它指向的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空:

```c++
// 如果p1不为空，检查他是否指向一个空string
if (p1 && p1->empty()) {
    *p1 = "hi";  // 如果p1指向一个空string，解引用p1，将一个新值赋予string
}
```

表12.1列出了shared_ptr和unique_ptr都支持的操作。只适用于shared_ptr的操作于表12.2中。

| **表12.1:shared_ptr和unique_ptr都支持的操作** |  |
|:- |:- |
| shared_ptr<T> sp | 空智能指针，可以指向类型为T的对象 |
| unique_ptr<T> up |  |
| p | 将p用做一个条件判断，若p指向一个对象，则为true |
| *p | 解引用p，获得指向它的对象 |
| p->mem | 等价于(*p).mem |
| p.get() | 返回p中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了 |
| p.swap(q) | 交换p和q中的指针 | 
| swap(p,q) |  |

| **表12.2:shared_ptr独有的操作** |  |
|:- |:- |
| make_shared<T>(args) | 返回一个shared_ptr,指向一个动态分配的类型为T的对象。使用args初始化此对象 |
| shared_ptr<T> p(q) | p是shared_ptr q 的拷贝；此操作会递增q中的计数器。q中的指针必须能转换为T* |
| p = q | p 和 q都是shared_ptr，所保存的指针必须能够相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放 |
| p.unique() | 若p.use_count()为1,返回true；否则返回false |
| p.use_count() | 返回与p共享对象的智能指针数量;可能很慢，主要用于调试 |

#### make_shared函数
最安全的分配和使用动态内存的方法是调用一个make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。与智能指针一样，make_shared也定义在头文件memory中。

当要用make_shared时，必须指定想要创建的对象的类型。定义方式与模板类相同，在函数名之后跟一个尖括号，在其中给出类型:

```c++
// 指向一个值为42的int的shared_ptr
shared_ptr<int> p3 = make_shared<int>(42);
// p4指向一个值为"999999999"的string
shared_ptr<string> p4 = make_shared<string>("999999999");
// p5指向一个值初始化的int，即值为0
shared_ptr<int> p5 = make_shared<int>();
```

类似顺序容器的emplac成员，make_shared用其参数来构造给定类型的对象。例如，调用make_shared<string>时传递的参数必须与string的某个构造函数相匹配，调用make_shared<int>时传递的参数必须能用来初始化一个int，以此类推，如果我们不传递任何参数，对象就会进行值初始化。

当然，我们通常用auto定义一个对象来保存make_shared的结果，这种方式比较简单:

```c++
// p6指向一个动态分配的空vector<sring>
auto p6 = make_shared<vector<string>>();
```

#### shared_ptr的拷贝和赋值
当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象:

```c++
auto p = make_shared<int>(42);  // p指向的对象只有p一个引用者。
auto q(p);  // p和q指向相同对象，此对象有两个引用者
```

我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数(reference count)。无论何时我们拷贝一个shared_ptr，计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给一个参数以及作为函数的返回值时，它所关联的计数器就会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁(例如一个局部的shared_ptr离开其作用域时)，计数器就会递减。

一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象:

```c++
auto r = make_shared<int>(42);  // r指向的int只有一个引用者
r = q;  // 给r赋值，令它指向另一个地址
        // 递增q指向的对象的引用计数
        // 递减r原来指向的对象的引用计数
        // r原来指向的对象已没有引用者，会自动释放
```

此例中我们分配了一个int，将其指针保存在r中。接下来，我们将一个新值赋予r。在此情况下，r是唯一指向此shared_ptr，在把q赋给r的过程中，此int被自动释放。

**Note:到底是用一个计数器还是其他数据结构来记录有多少指针共享对下那个，完全由标准库的具体实现来决定。关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象。**

#### shared_ptr自动销毁所管理的对象···
当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。它是通过另一个特殊的成员函数————析构函数(destructor)完成销毁工作的。类似于构造函数，每个类都有一个析构函数。就像构造函数控制初始化一样，析构函数控制此类型的对象销毁时做什么操作。

析构函数一般用来释放对象所分配的资源。例如，string的构造函数(以及其他string成员)会分配内存来保存构成的string的字符。string的析构函数就负责释放这些内存。类似的，vector的若干操作都会分配内存来保存其元素。vector的析构函数就负责销毁这些元素，并释放它们所占用的内存。

#### ···shared_ptr还会自动释放相关联的内存
当动态对象不再被使用时，shared_ptr类会自动释放动态对象，这一特性使得动态内存的使用变得非常容易。例如，我们可能有一个函数，它返回一个shared_ptr，指向一个Foo类型的动态分配的对象，对象是通过一个类型为T的参数进行初始化的:

```c++
// factory返回一个shared_ptr，指向一个动态分配的对象
shared_ptr<Foo> factory(T arg) {
    // 恰当的处理arg
    // shared_ptr负责释放内存
    return make_shared<Foo>(arg);
}
```

由于factory返回一个shared_ptr，所以我们可以确保它分配的对象会在恰当的时刻被释放。例如，下面的函数将factory返回的shared_ptr保存在局部变量中:

```c++
void use_factory(T arg) {
    shared_ptr<Foo> p = factory(arg);
    // 使用p
}  // p离开了作用域，他指向的内存会被自动释放掉
```

由于p是use_factory的局部变量，在use_factory结束时它将被销毁。当p被销毁时，将递减其引用计数并检查它是否为0.在此例中，p是唯一引用factory返回的内存的对象。由于p将要销毁,p指向的这个对象也会被销毁，所占用的内存会被释放。

但如果有其他shared_ptr也指向这块内存，它就不会被释放掉:

```c++
void use_factory(T arg) {
    shared_ptr<Foo> p = factory(arg);
    // 使用p
    return p;  // 当我们返回p时，引用计数进行了递增操作
}  // p离开了作用域，但它指向的内存不会被释放掉
```

在此版本中，use_factory中的return语句向此函数的调用者返回一个p的拷贝。拷贝一个shared_ptr会增加所管理对象的引用计数值。现在当p销毁时，他所指向的内存还有其他使用者。对于一块内存，shared_ptr类保证只要有任何shared_ptr对象引用它，它就不会被释放掉。

由于在最后一个shared_ptr销毁前都不会释放，保证shared_ptr在无用之后不再保留就非常重要了。如果你忘记了销毁程序不再需要的shared_ptr，程序仍会正确执行，但会浪费内存。shared_ptr在无用之后仍然保留的一种可能情况是，你讲shared_ptr存放在一个容器中，随后重拍了容器，从而不再需要某些元素。在这种情况下，你应该确保用erase删除那些不再需要的shared_ptr元素。

**Note:如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。**

#### 使用了动态生存期的资源的类
程序使用动态内存出于一下三种原因之一:
1.程序不知道自己需要使用多少对象
2.程序不知道所需对象的准确类型
3.程序需要在多个对象间共享数据

容器类是出于第一种原因而使用动态内存的典型例子，我们将在第15章看到出于第二种原因而使用动态内存的典型例子。在本节中，我们将定义一个类，它使用动态内存是为了让多个对象能共享相同的底层数据。

到目前为止，我们使用过的类中，分配的资源都与对应对象生存期一致。例如，每个vector"拥有"其自己的元素。当我们拷贝一个vector时，原vector和副本vector中的元素是相互分离的:

```c++
vector<string> v1;  // 空vector
{  // 新作用域
    vector<string> v2 = {"a", "an", "the"};
    v1 = v2;  // 从v2拷贝元素到v1中
}  // v2被销毁，其中的元素也被销毁
   // v1有三个元素，是原来v2中元素的拷贝
```

由一个vector分配的元素只有当这个vector存在时才存在。当一个vector被销毁时，这个vector中的元素也都被销毁。

但某些类分配的资源具有与原对象相独立的生存期。例如，假定我们希望定义一个名为Blob的类，保存一组元素，与容器不同，我们希望Blob对象的不同拷贝之间共享相同的元素。即，当我们拷贝一个Blob时，原Blob对象及其拷贝应该引用相同的底层元素。

一般而言，如果两个对象共享底层数据时，当某个对象被销毁时，我们不能单方面地销毁底层数据:

```c++
Blob<string> b1;  // 空Blob
{  // 新作用域
    Blob<string> b2 = {"a", "an", "the"};
    b1 = b2;  // b1和b2共享相同的元素
}  // b2被销毁了，但b2中的元素不能销毁
   // b1指向最初由b2创建的元素
```

在此例中，b1和b2共享相同的元素。当b2离开作用域时，这些元素必须保留，因为b1仍在使用它们。

**Note:使用动态内存的一个常见原因时允许多个对象共享相同的状态**

#### 定义StrBlob类
最终，我们会将Blob类实现为一个模板，但我们知道16.1.2节才会学习模板的相关知识。因此，我们先管理一个string的类，此版本命名为StrBlob。

实现一个新的集合类型的最简单方法是使用某个标准库容器来管理元素。采用这种方法，我们可以借助标准库类型来管理元素所使用的内存空间。在本例中，我们将使用vector来保存元素。

但是，我们不能在一个Blob对象内直接保存vector，因为一个对象的成员在对象销毁时也会被销毁。例如，假定b1和b2是两个Blob对象，共享相同的vector。如果此vector保存在其中一个Blob中——————例如b2中，那么当b2离开作用域时，此vector也将被销毁，也就是说其中的元素都将不复存在。为了保证vector中的元素继续存在，我们将vector保存在动态内存中。

为了实现我们所希望的数据共享，我们为每个StrBlob设置一个shared_ptr来管理动态分配的vector。此shared_ptr的成员将记录有多少个StrBlob共享相同的vector，并在vector的最后一个使用者被销毁时释放vector。

我们还需要确定这个类应该提供什么操作。当前，我们将实现一个vector操作的小的子集。我们修改访问元素的操作(如fornt和back):在我们的类中，如果用户试图访问不存在的元素，这些操作会抛出一个异常。

我们的类有一个默认构造函数和一个构造函数，接受单一的initializer_list<string>类型参数。此构造函数可以接受一个初始化器的花括号列表。

```c++
class StrBlob {
public:
    typedef std::vector<std::string>::size_type size_type;
    StrBlob();
    StrBlob(std::initializer_list<std::string> i1);
    size_type size() const { return data->size(); }
    // 添加和删除元素
    void push_back(const std::string &t) { data->push_back(t); }
    void pop_back();
    // 元素访问
    std::string & front();
    std::string & back();

private:
    std::shared_ptr<std::vector<std::string>> data;
    // 如果data[i]不合法，抛出一个异常
    void check(size_type i, const std::string &msg) const;
};
```

在此类中，我们实现了size、empty和push_back成员。这些成员通过指向底层vector的data成员来完成它们的工作。例如，对一个StrBlob对象调用size()会调用data->size(),以此类推。

#### StrBlob构造函数
两个构造函数都是用初始化列表来初始化其data成员，令它指向一个动态分配的vector。默认构造函数分配一个空vector:

```c++
StrBlob::StrBlob() : data(make_shared<vector<string>>()) {}
StrBlob::StrBlob(initializer_list<string> il) : data(make_shared<vector<string>>(il)) {}
```

接受一个initializer_list的构造函数将其参数传递给对应的vector构造函数。此构造函数通过拷贝列表中的值来初始化vector的元素。

### 元素访问成员函数
pop_back、front和back操作访问vector中的元素。这些操作在试图访问元素之前必须检查元素是否存在。由于这些成员函数需要做相同的检查操作，我们为StrBlob定义了一个名为check的private工具函数，它检查一个给定索引是否在合法范围内。除了索引，check还接受一个string参数，它会将此参数传递给异常处理程序，这个string描述了错误内容:

```c++
void check(size_type i, const string &msg) const {
    if (i >= data->size()) {
        throw out_of_range(msg);
    }
}
```

pop_back和元素访问成员函数首先调用check。如果check成功，这些成员函数继续利用底层vector的操作来完成自己的工作:

```c++
string& StrBlob::front() {
    // 如果vector为空，check会抛出一个异常
    check(0, "front on empty StrBlob");
    return data->front();
}

string& StrBlob::back() {
    check(0, "back on empty StrBlob");
    retrun data->back();
}

void StrBlob::pop_back() {
    check(0, "pop_back on empty StrBlob");
    data->pop_back();
}
```

#### StrBlob的拷贝、赋值和销毁
类似Sales_data类，StrBlob使用默认版本的拷贝、赋值和销毁成员函数来对此类型的对象进行这些操作。默认情况下，这些操作拷贝、赋值和销毁类的数据成员。我们的StrBlob类只有一个数据成员，它是shared_ptr类型。因此，当我们拷贝，赋值或销毁一个StrBlob对象时，它的shared_ptr成员会被拷贝、赋值或者销毁。

如前所说，拷贝一个shared_ptr会递增其引用；将一个shared_ptr赋予另一个shared_ptr会递增右侧shared_ptr的引用计数，而递减左侧shared_ptr的引用计数。如果一个shared_ptr的引用计数变为0，它所指向的对象会被自动销毁。因此，对于由StrBlob构造函数分配的vector，当最后一个指向它的StrBlob对象被销毁时，它会随之被自动销毁。

### 12.1.2 直接管理内存
C++语言定义了两个运算符来分配和释放动态内存。运算符new分配内存，delete释放new分配的内存。

相对于智能指针，使用这两个运算符管理内存非常容易出错，随着我们逐步详细介绍这两个运算符，这一点会更为清楚。而且，自己直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。因此，使用智能指针的程序更容易编写和调试。

**WARNING:在学习第13章之前，除非使用智能指针来管理内存，否则不要分配动态内存**

#### 使用new动态分配和初始化对象
在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该兑现的指针:

```c++
int *pi = new int;  // pi指向一个动态分配的，未初始化的无名对象
```

此new表达式在自由空间构造一个int型对象，并返回指向该对象的指针。

默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值是未定义的，而类类型对象将用默认构造函数进行初始化:

```c++
string *ps = new string;  // 初始化为空string
int *pi = new int;  // pi指向一个未初始化的int
```

我们可以使用直接初始化方式来初始化一个动态分配的对象。我们可以使用传统的构造方式(使用圆括号)，在新标准下，也可以使用列表初始化(使用花括号):

```c++
int *pi = new int(1024);  // pi指向的对象的值未1024
string *ps = new string(10,'9');  // *ps为"9999999999"
// vector有10个元素，值依次从0到9
vector<int> *pv = new vector<int> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
```

也可以对动态分配的对象进行值初始化，只需在类型名之后跟一对空括号即可:

```c++
string *ps1 = new string;  // 默认初始化为空string
string *ps2 = new string();  // 值初始化为空string
int *pi1 = new int;  // 默认初始化; *pi1的值未定义
int *pi2 = new int();  // 值初始化为0; *pi2为0
```

对于定义了自己的构造函数的类类型(例如string)来说，要求值初始化是没有意义的:不管采用什么形式，对象都会通过默认构造函数来初始化。但对于内置类型，两种形式的差别就很大了:值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。类似的，对于类中那些依赖于编译器合成的默认构造函数的内置类型成员:如果它们未在类内被初始化，那么他们的值也是未定义的。

**Best Practices:出于与变量初始化相同的原因，对动态分配的对象进行初始化通常是个好主意。**

如果我们提供了一个括号包围的初始化器，就可以使用auto从此初始化器来推断我们想要分配的对象的类型。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器时才可以使用auto:

```c++
auto p1 = new auto(obj);  // p指向一个与obj类型相同的对象
auto p2 = new auto{a, b, c};  // 错误，括号中只能有单个初始化器
```

p1的类型是一个指针，指向从obj自动推断出的类型。若obj是一个int，那么p1就是int*，若obj是一个string，那么p1是一个string*;依次类推。新分配的对象用obj的值进行初始化。

#### 动态分配的const对象
用new分配const对象是合法的:

```c++
// 分配并初始化一个const int
const int *pci = new const int(1024);
// 分配并默认初始化一个const的空string
const string *psc = new const string;
```

类似其他任何const对象，一个动态分配的const对象必须进行初始化。对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。由于分配的对象是const的，new返回的指针是一个指向const的指针。

#### 内存耗尽
虽然现代计算机通常都配备大容量内存，但是自由空间被耗尽的情况还是有可能发生。一旦一个程序用光了它所有可用的内存，new表达式就会失败。默认情况下，如果new不能非陪所要求的内存空间，它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来组织它抛出异常:

```c++
// 如果分配失败，new返回一个空指针
int *p1 = new int;  // 如果分配失败，new抛出std::bad_alloc
int *p2 = new (nothrow) int;  // 如果分配失败，new返回一个空指针
```

我们称这种形式的new为定位new，其原因我们将在19.1.2节中解释。定位new表达式允许我们向new传递额外的参数。我们传递给它一个由标准库定义的名为nothrow的对象。如果将nothrow传递给new，我们的意图是告诉它不能抛出异常。如果这种形式的new不能分配所需内存，它会返回一个空指针。bad_alloc和nothrow都定义在头文件new中。