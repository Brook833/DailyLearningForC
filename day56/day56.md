2022.11.12



### 将一个容器初始化为另一个容器的拷贝
将一个新容器创建为另一个容器的拷贝的方法有两种：可以直接拷贝整个容器，(array除外)拷贝一个由迭代器对指定的元素范围。

为了创建一个容器为另一个容器的拷贝，两个容器的类型及元素类型必须匹配。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不过，只要能将要拷贝的元素转换为初始化的容器的元素类型即可。

```c++
//每个容器有三个元素，用给定的初始化器进行初始化
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};

list<string> list2(authors);  // 正确，类型匹配
deque<string> authList(authors);  // 错误，容器类型不匹配
vector<string> words(articles);  // 错误，怨怒是类型不匹配
forward_list<string> words(articles.begin(), articles.end());  // 正确，可以将const char*元素转换为string
```

**Note:当将一个容器初始化为另一个容器的拷贝时，两个容器类型和元素类型都必须相同**

接受两个迭代器参数的构造函数用这两个迭代器表示我们想要拷贝的一个元素范围。与以往一样，两个迭代器分别标记想要拷贝的第一个元素和尾元素之后的位置。新容器的大小与范围中元素的数目相同。新容器中的每个元素都用范围中对应元素的值进行初始化。

由于两个迭代器表示一个范围，因此可以使用这种构造函数来拷贝一个容器中的子序列。例如，假定迭代器it表示authors中的一个元素，我们可以编写如下代码：

```c++
// 拷贝元素，直到(但不包括)it指向的元素
deque<string> authList(authors.begin(), it);
```

### 列表初始化
在新标准中，我们可以对一个容器进行列表初始化:

```c++
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};
```

当这样做时，我们就显式地指定了容器中每个元素的值。对于除array之外的容器类型，初始化列表还隐含的制定了容器的大小:容器将包含于初始值一样多的元素。

### 与顺序容器大小相关的构造函数
除了与关联容器相同的构造函数外，顺序容器(array除外)还提供另一个构造函数，它接受一个容器大小和一个(可选的)元素初始值。如果我们不提供元素初始值，则标准库会创建一个值初始化器：

```c++
vector<int> ivec(10, -1);  // 10个int元素，每个都初始化为-1
list<string> svec(10,"hi!");  // 10个strings,每个都初始化为"hi!"
forward_list<int> ivec(10);  // 10个元素，每个都初始化为0
deque<string> svec(10);  // 10个元素，每个都是空string
```

如果元素类型是内置类型或者是具有默认构造函数的类类型，可以只为构造函数提供一容器大小参数。如果元素类型没有默认构造函数，除了大小参数外，还必须指定一个显式的元素初始值。

**Note:只有顺序容器的构造函数才接受大小参数，关联容器并不支持**

### 标准库array具有固定大小
与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器的大小。

```c++
array<int, 42>  // 类型为:保存42个int的数组
array<string, 10>  // 类型为:保存10个string的数组
```

为了使用array类型，我们必须同时指定元素类型和大小:

```c++
array<int, 10>::size_type i;  // 数组类型包括元素类型和大小
array<int>::size_type j;  // 错误:array<int>不是一个类型
```

由于大小是array类型的一部分，array不支持普通的容器构造函数。这些构造函数都会确定容器的大小，要么隐式的，要么显式的。而允许用户向一个array构造函数传递大小参数，最好情况下也是多余的，而且容易出错。

array大小固定的特性也影响了它所定义的构造函数的行为。与其他容器不同，一个默认构造的array是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始化，就像一个内置数组中的元素那样。如果我们对array进行列表初始化，初始值的数目必须等于或小于array的大小。如果初始值数目小于array的大小，则它们被用来初始化array中靠前的元素，所有剩余元素会进行值初始化。在这两种情况下，如果元素类型是一个类类型，那么该类必须有一个默认构造函数，以使值初始化能够进行：

```c++
array<int, 10> ial;  // 10个默认初始化的int
array<int, 10> ia2 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};  // 列表初始化
array<int, 10> ia3 = {42};  // ia3[0]为42，剩余元素为0
```

值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但array并无此限制：

```c++
int digs[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int cpy[10] = dig;  // 错误：内置数组不支持拷贝或赋值
array<int, 10> digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
array<int, 10> copy = digits;  // 正确，只要数组类型匹配即合法
```

与其他容器一样，array也要求初始值的类型必须与要创建的容器类型相同。此外，array还要求元素类型和大小也都一样，因为大小是array类型的一部分。

## 9.2.5 赋值和swap
表9.4中列出的与赋值相关的运算符可用于所有容器。赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝：

```c++
c1 = c2;  // 将c1的内容替换为c2中元素的拷贝
c1 = {a, b ,c};  // 复制后，c1大小为3
```

第一个赋值运算后，左边容器将于右边容器相等。如果两个容器原来大小不同，赋值运算后两者大小斗鱼右边容器的原大小相同。第二个赋值运算后，c1的size变为3，即花括号列表中值的数目。

与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型。

```c++
array<int, 10> a1 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
array<int, 10> a2 = {0};  // 所有元素均为0
a1 = a2;  // 替换a1中的元素
a2 = {0};  // 错误，不能将一个花括号列表赋予数组
```

由于右边运算对象的大小可能与左边运算对象的大小不同，因此array类型不支持assign，也不允许用花括号包围的值列表进行赋值。

| **表9.4 容器赋值运算** |  |
|:- |:- |
| c1 = c2 | 将c1中的元素替换为c2中元素的拷贝。c1和c2必须具有相同的类型 |
| c = {a, b, c} | 将c1中元素替换为列表初始化列表中元素的拷贝(array不适用) |
| swap(c1, c2) 或 c1.swap(c2) | 交换c1和c2中的元素。c1和c2必须具有相同的类型。swap通常比从c2向c1拷贝元素快得多 |
| **assign操作不适用于关联容器和array** |  |
| seq.assign(b, e) | 将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素 |
| seq.assign(i1) | 将seq中的元素替换为初始化列表i1中的元素 |
| seq.assign(n, t) | 将seq中的元素替换为n个值为t的元素 |

**WARNING: 赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效(容器类型为array和string的情况除外)**

### 使用assign(仅顺序容器)
赋值运算符要求左边和右边的运算对象具有相同的类型。它将右边运算对象中所有元素拷贝到左边运算对象中。顺序容器(array除外)还定义了一个名为assign多的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign操作用参数将所指定的元素(的拷贝)替换左边容器中的所有元素。例如，我们可以用assign实现将一个vector中的一段char*值赋予一个list中的string:

```c++
list<string> names;
vector<const char*> oldstyle;
names = oldstyle;  // 错误：容器类型不匹配
names.assign(oldstyle.cbegin(), oldstyle.cend());
```

这段代码中assign的调用将names中的元素替换为迭代器指定的范围中的元素拷贝。assign的参数决定了容器中将有多少个元素以及它们的值都是什么。

**WARNING: 由于其旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器**

assign的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器中原有的元素：

```c++
list<string> slist(1);  // 1个元素，为空string
slist1.assign(10, "Hiya!");  // 10个元素，每个都是"Hiya!"
// 等价于slist1.clear(); slist1.insert(slist1.begin(), 10, "Hiya!");
```

### 使用swap
swap操作交换两个相同类型容器的内容。调用swap之后，两个容器中的元素将会交换:
```c++
vector<string> svec1(10);  // 10个元素的vector
vector<string> svec2(24);  // 23个元素的vector
swap(svec1, svec2);
```

调用swap后，svec1将包含24个string元素，svec2将包含10个string。除array外，交换两个容器内容的操作保证会很快——元素本身并未交换，swap只是交换了两个容器内部数据结构。

**Note： 除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。**

元素不会被移动的事实意味着，除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前的那些元素。但是，在swap之后，这些元素已经属于不同的容器了。例如，假定iter在swap之前指向svec1[3]的string,那么swap之后它指向svec2[3]的元素。与其他容器不同，对一个string调用swap会导致迭代器、引用和指针失效。

与其他容器不同，swap两个array会真正交换它们的元素。因此，交换两个array所需的时间与array中元素的数目成正比。

因此，对于array，在swap操纵之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换。

在新标准库中，容器既提供成员函数版本的swap，也提供非成员版本的swap。而早期标准库版本只提供成员函数版本的swap。非成员版本的swap在泛型编程中是非常重要的。统一使用非成员版本的swap是一个好习惯。

## 9.2.6 容器大小操作
除了一个例外，每个容器类型都有三个与大小相关的操作。成员函数size返回容器中元素的数目；empty当size为0时返回布尔值true，否则返回false;max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。forward_list支持max_size和empty，但不支持size。

## 9.2.7 关系运算符
每个容器类型都支持相等运算符(==和!=);除了无序关联容器外的所有容器都支持关系运算符(>、>=、<、<=)。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。即，我们只能将一个vector<int>与另一个vector<int>进行比较，而不能将一个vector<int>与一个list<int>或一个vector<double>进行比较。

比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与string的关系运算类似：
> + 如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等。
> + 如果两个容器大小不同，但较小容器中每个元素都等于较大元素中的对应元素，则较小容器小于较大容器。
> + 如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的比较结果。

下面的例子展示了这些关系运算符是如何工作的:

```c++
vector<int> v1 = {1, 3, 5, 7, 9, 12};
vector<int> v2 = {1, 3, 9};
vector<int> v3 = {1, 3, 5, 7};
vector<int> v4 = {1, 3, 5, 7, 9, 12};
v1 < v2;  // true, v1和v2元素在元素[2]处不同：v1[2]小于v2[2]
v1 < v3;  // false, 所有元素都相等，但v3中元素数目更少
v1 == v4;  // true, 每个元素都相等，且v1和v4大小相同
v1 == v2;  // false, v2元素数目比v1少
```

### 容器的关系运算符使用元素的关系运算符完成比较
**Note: 只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器**

容器的相等运算符实际上是使用元素的==运算符实现比较的，而其他关系运算符是使用元素的<运算符。如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算。我们在第7章中定义的Sales_data类型并未定义==和<运算符。因此，就不能比较两个保存Sales_data元素的容器：

```c++
vector<Sales_data> storeA, storeB;
if (storeA < StoreB)  // 错误，Sales_data没有<运算符
```
