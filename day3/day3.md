2022.9.10
复习C++primer 2.3复合类型

## 引用
### 引用并非对象
C++11中新增了一种引用，所谓的右值引用（rvalue refence),主要作用于内置类。

严格来说，当我们使用术语”引用“时，指的其实是左值引用。（lvalue reference）。

一般在初始化变量时，是将初始值拷贝至新建的对象中。在定义引用时，程序把引用和它的初始值绑定（bind)在一起，而不是将初始值拷贝给引用。

一般对引用的操作，都是在与其绑定的对象上进行的。

#
## 指针
### 指针本身是一个对象
允许对指针赋值和拷贝，而且在指针的生命周期内可以先后指向不同的对象。

指针无需在定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

指针值应属于下列4种状态之一：

1.指向一个对象

2.指向紧邻对象所占空间的下一个位置。

3.空指针，没有指向任何对象。

4.无效指针，上述情况外的其他值。

试图拷贝或以其他方式访问无效指针都将引发错误。编译器并不负责检查此类错误，这一点和试图使用未经初始化的变量时一样的。

对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值。（解引用操作仅适用于那些确实指向了某个对象的有效指针）

 int &r = i; //&紧随类型名出现，r是一个引用。
 
 int *p; //*紧随类型名出现，p是一个指针。
 
 p = &i; //&出现在表达式中,是一个取地址符。

*p = i; //*出现在表达式中，是一个解引用符。

int &r2 = *p; //r2是引用，*是解引用符。

NULL预处理变量，不属于命名空间std，由预处理器负责管理，实际为0.

void* 是一种特殊的指针类型，可用于存放任意对象的地址。不同的是，我们对该地址中到底是个什么类型的对象并不了解。因此我们不能直接操作void*指针所指的对象。

以void*视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象。