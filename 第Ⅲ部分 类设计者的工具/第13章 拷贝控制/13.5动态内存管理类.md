# 13. 5 动态内存管理类
某些类需要在运行时分配可变大小的内存空间。这种类通常可以(并且如果他们确实可以的话，一般应该)使用标准库容器来保存它们的数据。例如，我们的StrBLob类使用一个vector来管理其元素的底层内存。

但是，这一策略并不是对每个类都适用:某些类需要自己进行内存分配。这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存。

例如，我们将实现标准库类的一个简化版本。我们所做的是不使用模板，我们的类只用于string。因此，它被命名为StrVec。

### StrVec类的设计
回忆一下，vector类将其元素保存在连续内存中。为了获得可接受的性能，vector预先分配足够的内存来保存可能需要的更多元素。vector的每个添加元素的成员函数会检查是否由空间容纳更多的元素。如果有，成员函数会在下一个可用位置构造一个对象。如果没有可用空间，vector就会重新分配空间:它获得新的空间，将已有元素移动到新空间中，释放旧空间，并添加新元素。

我们在StrVec中使用相同的策略。我们将使用一个allocator来获得原始内存。由于allocator分配的内存是未构造的，我们将在需要添加新元素时用alloctor的construct成员在原始内存中创建对象。类似的，当我们需要删除一个元素时，我们将使用destory成员来销毁元素。

每个StrVec有是哪个指针成员指向其元素所使用的内存:
> + elements,指向分配的内存中的首元素
> + first_free,指向最后一个实际元素之后的位置
> + cap,指向分配的内存末尾之后的位置

除了这些指针之外，StrVec还有一个名为alloc的静态成员，其类型为alloctor<string>。alloc成员会分配StrVec使用的内存。我们的类还有四个工具函数:
> + alloc_n_copy会分配内存，并拷贝一个给定范围中的元素。
> + free会销毁构造的元素并释放内存
> + chk_n_alloc保证StrVec至少有容纳一个新元素的空间。如果没有空间添加新元素，chk_n_alloc会调用reallocate来分配更多内存。
> + reallocate在内存用完时为StrVec分配新内存。

虽然我们关注的是类的实现，但我们也将定义vector接口中的一些成员。

### StrVec类定义
如下所示:

```c++
class StrVec {
private:
    static std::allocator<std::string> alloc;  // 分配元素
    std::string *elements;                     // 指向数组首元素的指针
    std::string *first_free;                   // 指向数组最后一个实际元素之后的位置
    std::string *cap;                          // 指向数组尾后位置的指针

    void chk_n_alloc() {             // 被添加元素的函数所使用
        if (size() == capacity()) {
            reallocate();
        }
    }
    std::pair<std::string*, std::string*> alloc_n_copy(const std::string*, const std::string*);  // 工具函数，被拷贝构造函数，赋值运算符和析构函数使用
    void free();  // 销毁元素并释放内存
    void reallocate();  //获得更多内存并拷贝已有元素

public:
    StrVec():elements(nullptr),first_free(nullptr),cap(nullptr) {}  // 对allocator成员进行默认初始化
    StrVec(const StrVec&)
    StrVec& operator= (const StrVec&);
    ~StrVec();

    void push_back(const std::string&);  // 拷贝元素
    size_t size() const { return first_free - elements; }
    size_t capacity() const { return cap - elements; }
    std::string *begin() const { return elements; }
    std::string *end() const { return first_free; }
};
```

类定义了多个成员:
> + 默认构造函数(隐式地)默认初始化alloc并(显式地)将指针初始化为nullptr，表明没有元素。
> + size成员返回当前真正在使用的元素的数目，等于first_free - elements。
> + capacity成员返回StrVec可以保存的元素的数量，等价于cap-elements。
> + 当没有空间容纳新元素，即cap = first_free时，chk_alloc会为StrVec重新分配内存。
> + begin和end成员分别返回指向首元素(即elements)和最后一个构造的元素之后位置(即first_free)的指针。

### 使用construct
函数push_back调用chk_n_alloc确保有空间容纳新元素。如果需要，chk_n_alloc会调用reallocate。当chk_n_alloc返回时，push_back知道必有空间容纳新元素。他要求其allocator成员来construct新的尾元素:

```c++
void StrVec::push_back(const string& s) {
    chk_n_alloc();  // 确保有空间容纳新元素
    alloc.construct(first_free++, s);  // 在fist_free指向的元素中构造s的副本。
}
```

当我们用allocator分配内存时，必须记住内存是未构造的。为了使用此原始内存，我们必须调用construct，在此内存中构造一个对象。传递给construct的第一个参数必须是一个指针，指向调用allocate所分配的未构造的内存空间。剩余参数确定用哪个构造函数来构造对象。在本例中，只有一个额外参数，类型为string，因此会使用string的拷贝构造函数。

值得注意的是，对construct的调用也会递增first_free，表示已经构造了一个新元素。它使用前置递增，因此这个调用会在first_free当前值指定的地址构造一个对象，并递增first_free指向下一个未构造的元素。

### alloc_n_copy成员