# 13.6 对象移动
新标准的一个最主要的特性就是可以移动而非拷贝对象的能力。很多情况下都会发生对象拷贝。在其中某些情况下，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。

如我们已经看到的，我们的StrVec类是这种不必要的拷贝一个很好的例子。在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素。使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含不能被共享的资源(如指针或IO缓冲)。因此，这些类型的对象不能拷贝但可以移动。

在旧C++标准中，没有直接的方法移动对象。因此，即使不必拷贝对象的情况下，我们也不得不拷贝。如果对象较大，或是对象本身要求分配内存空间(如string)，进行不必要的拷贝代价非常高。类似的，在旧版本的标准库中，容器中所保存的类必须是可拷贝的。但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动即可。

## 13.6.1 右值引用
为了支持移动操作，新标准引入了一种新的引用类型———右值引用(rvalue reference)。所谓右值引用就是必须绑定到右值的引用。我们通过&&而不是&来获得右值引用。如我们将要看到的，右值引用有一个重要的性质———只能绑定一个将要销毁的对象。因此，我们可以自由的将一个右值引用的资源"移动"到另一个对象中。

回忆一下，左值和右值是表达式的属性。一些表达式生成或要求左值，而另外一些则生成或要求右值。一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。

类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。如我们所知，对于常规引用(为了与右值引用区分开，可以称为左值引用)，我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的绑定特性:我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值直接绑定到一个左值上:

```c++
int i = 42;
int &r = i;              // 正确，r引用i
int &&r = i;             // 错误，不能将一个右值引用绑定到一个左值上
int &r2 = i * 42;        // 错误，i * 42是一个右值
const int &r3 = i * 42;  // 正确，我们可以将一个const的引用绑定到一个右值上
int &&r2 = i * 42;       // 正确，将rr2绑定到乘法结果上
```

返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值表达式的例子。我们可以将一个左值引用绑定到这类表达式的结果上。

返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个const的左值引用或者一个右值引用绑定到这类表达式上。

### 左值持久；右值短暂
考察左值和右值表达式的列表，两者互相区别之处旧很明显了:左值有持久的状态，而右值要么是字面变量，要么是在表达式求值过程中创建的临时对象。

由于右值引用只能绑定到临时对象，我们得知:
> + 所引用的对象将要被销毁
> + 改对象没有其他用户

这两个特性意味着:使用右值的代码可以自由的接管所引用的对象的资源。

==Note:
右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象"窃取"状态。==

### 变量是左值
变量可以看作只有一个运算对象而没有运算符的表达式，虽然我们很少这样看待变量。类似其他任何表达式，变量表达式也有左值/右值属性。变量表达式都是左值。带来的结果就是，我们不能将一个右值引用绑定到一个右值引用类型的变量上:

```c++
int &&rr1 = 42;   // 正确，字面量是右值
int &&rr2 = rr1;  // 错误，表达式rr1是左值
```

其实有了右值表示临时对象这一观察结果，变量是左值这一特性并不令人惊讶。毕竟，变量是持久的，直至离开作用域才被销毁。

==Note:
变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量时右值引用类型也不行。==

### 标准库的move函数
虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式的将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件utility中。

```c++
int &&rr3 = std::move(rr1);  // 正确
```

move调用告诉编译器:我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用move就意味着承诺:除了对rr1赋值或销毁它外，我们就不再使用它。在调用move之后，我们不能对移后源对象的值做任何假设。

==Note:
我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。==

如前所述，与大多数标准库名字的使用不同，对move我们不提供using声明。我们直接调用std::move而不是move。

**WARNING:使用move的代码应该使用std::move而不是move。这样做可以避免潜在的名字冲突。**

## 13.6.2 移动构造函数和移动赋值运算符
类似string类(及其他标准库类)，如果我们自己的类也同时支持移动和拷贝。那么也能从中受益。为了让我们自己的类型支付移动操作，需要为其定义移动构造函数和移动赋值运算符。这两个成员类似对应的拷贝操作，但它们从给定对象"窃取"资源而不是拷贝资源。

类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。

除了完成资源移动，移动构造函数还必须确保移后源对象出于这样一个状态————销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源————这些资源的所有权已经归属新创建的对象。

作为一个例子，我们位StrVec类定义移动构造函数，实现从一个StrVec到另一个StrVec的元素移动而非拷贝:

```c++
StrVec::StrVec(StrVec &&s) noexcept  // 移动操作不应抛出任何异常
    // 成员初始化器接管s中的资源
    : elements(s.elements), first_free(s.first_free), cap(s.cap) {
        // 令s进入这样的状态————对其运行析构函数是安全的
        s.elements = s.first_free = s.cap = nullptr;
}
```

简短解释noexcept(它通知标准库我们的构造函数不抛出任何异常)，但让我们线分析一下此构造函数完成什么工作。

与拷贝构造函数不同，移动构造函数不分配任何新内存；它接管给定的StrVec中的内存。在接管内存之后，它将给定对象中的指针都置为nullptr。这样就完成了从给定对象的移动操作，此对象将继续存在。最终，移后源对象会被销毁，意味着将在其上运行析构函数。StrVec的析构函数在first_free上调用deallocate。如果我们忘记了改变s.first_free，则销毁移后源对象就会释放掉我们刚刚移动的内存。

### 移动操作、标准库容器和异常
由于移动操作“窃取”资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。当编写一个不抛出异常的移动操作时，我们应将此事通知标准库。我们将看到，除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。

一种通知标准库方法是在我们的构造函数中指明noexcept。noexcept是新标准引入的。目前重要的是要知道，noexcept是我们承诺一个函数不抛出异常的一种方法。我们在一个函数的参数列表后指定noexcept。在一个构造函数中，noexcept 出现在参数列表和初始化列表开始的冒号之间:

```c++
class StrVec{
public:
    StrVec(StrVec&&) noexcept;  // 移动构造函数
};

StrVec::StrVec(StrVec&& s) noexcept : /*成员初始化器*/ {/*构造函数体*/}
```

我们必须在类头文件的声明种和定义中(如果定义在类外的话)都指定noexcept。

==Note:
不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。==

搞清楚为什么需要noexcept能帮助我们深入理解标准库是如何与我们自定义的类型交互的。我们需要指出一个移动操作不抛出异常，这是因为两个相互关联的事实:首先，虽然移动操作通常不抛出异常，但抛出异常也是允许的；其次，标准库容器能对异常发生时自身的行为提供保障。例如，vector保证，如果我们调用push_back时发生异常，vector自身还是不不会发生改变。

类似对应的StrVec操作，对一个vector调用push_back可能要求为vector重新分配内存空间。当重新分配vector的内存时，vector将元素从旧空间移动到新内存中，就像我们在reallocate中所作的那样。

如我们刚刚看到的那样，移动一个对象通常会改变它的值。如果重新分配过程中使用了移动构造函数，且在移动了部分而不是全部元素后抛出了一个异常，就会产生问题。旧空间中的移动源元素已经被改变了，而新空间中未构造的元素可能尚不存在。在此情况下，vector将不能满足自身半尺不变的要求。

另一方面，如果vector使用了拷贝构造函数且发生了异常，它可以很容易的满足要求，在此情况下，当在新内存中构造元素时，旧元素保持不变。如果此时发生了异常，vector是可以释放新分配的(但还未成功构造的)内存并返回。vector原有的元素仍然存在。

为了避免这种潜在问题，除非vector知道元素类型的移动构造不会抛出异常，否则在重新分配内存的过程中，他就必须使用拷贝构造函数而不是移动构造函数。如果希望在vector重新分配内存这类情况下对我们自定义类型的对象进行移动而不是拷贝，就必须显式的告诉标准库我们的移动构造函数可以安全使用。我们将通过移动构造函数(及移动复制运算符)标记为noexcept来做到这一点。

### 移动赋值运算符
移动赋值运算符执行与析构函数和移动构造函数相同的工作。与移动构造函数一样，如果我们的移动赋值算符不抛出任何异常，我们就应该将他标记为noexcept。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值:

```c++
StrVec &StrVec::operator= (StrVec &&rhs) noexpect {
    // 直接检测自赋值
    if (this != &rhs) {
        free();                       // 释放已有元素     
        elements = rhs.elements;      // 从rhs接管资源
        first_free = rhs.first_free;  
        cap = rhs.cap;
        // 将rhs置于可惜购状态
        rhs.elements = rhs.first_free =  rhs.cap = nullptr;
    }
    return *this;
}
```

在此例中，我们直接检查this指针与rhs的地址是否相同。如果相同，右侧和左侧运算对象指向相同的对象，我们不需要做任何事情。否则，我们释放左侧运算符对象所使用的内存，并接管给定对象的内存。与移动构造函数一样，我们将rhs中的指针置为nullptr。

我们费心的去检查自复制情况看起来有些奇怪。毕竟，移动赋值运算符需要右侧运算对象的一个右值。我们进行检查的原因是此右值可能是move调用的返回结果。与其他任何赋值运算符一样，关键点是我们不能在使用右侧运算对象的资源之前就释放左侧对象的资源(可能是相同的资源)。

### 移后源对象必须可析构
从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁。因此，当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。我们StrVec的移动操作满足这一要求，这是通过将移后源对象的指针成员置为nullptr来实现的。

除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的。一般来说，对象有效就是指可以安全的为其赋予新值或者可以安全的使用而不依赖其当前值。另一方面，移动操作对移后源对象中留下的值没有任何要求。因此，我们的程序不应该依赖于移后源对象中的数据。

例如，当我们从一个标准库string或容器对象移动数据时，我们知道移后源对象仍然保持有效。因此，我们可以对他执行诸如empty或size这些操作。但是，我们不知道将会得到什么结果。我们可能期望一个移后源对象是空的，但这并没有保证。

我们StrVec类的移动操作将移后源对象置于与默认初始化的对象相同的状态。因此，我们可以继续对移后源对象执行所有的StrVec操作，与任何其他默认初始化的对象一样。而其他内部结构更为复杂的类，可能表现出完全不同的行为。

**WARNING:在移动操作之后，移后源必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设**

### 合成的移动操作
与处理拷贝构造函数和拷贝赋值运算符一样，编译器也会合成移动构造函数和移动赋值运算符。但是，合成移动操作的条件与合成拷贝操作的条件大不相同。

回忆一下，如果我们不声明自己的拷贝构造函数或拷贝赋值运算符，编译器总会为我们合成这些操作。拷贝操作要么被定义为逐成员拷贝，要么定义为对象复制，要么定义为删除的函数。

与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是，如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为他合成移动构造函数和移动赋值运算符了。因此，某些类就没有移动构造函数或移动赋值运算符。如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作。

只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员:

```c++
// 编译器会为X和hasX合成移动操作
struct X {
    int i;         // 内置类型可以移动
    std::string s; // string定义了自己的移动操作
};

struct hasX {
    X mem;  // X有合成的移动操作
};
X x, x2 = std::move(x);        // 使用合成的移动构造函数
hasX hx, hx2 = std::move(hx);  // 使用合成的移动构造函数
```

==Note:
只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。==

与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显式的要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。除了一个重要例外，什么时候将合成的移动操作定义为删除的函数遵循与定义删除的合成拷贝操作类似的原则:
> + 与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是:有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动运算符的情况类似。
> + 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。
> + 类似拷贝赋值运算符，如果有类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。
> + 类似拷贝赋值运算符，如果有类成员是const的或是引用，则类的移动赋值运算符被定义为删除的。

例如，假定Y是一个类，它定义了自己的拷贝构造函数但未定义移动构造函数:

```c++
struct hasY {
    hasY() = default;
    hasY(hasY&&) = default;
    Y mem;  // hasY将有一个删除的移动构造函数
};
hasY hy, hy2 = std::move(hy);  // 错误，移动构造函数是删除的
```

编译器可以拷贝类型为Y的对象，但不能移动他们。类hasY显式的要求一个移动构造函数，但编译器无法为其生成。因此，hasY会有一个删除的移动构造函数。如果hasY忽略了移动构造函数的声明，则编译器根本不能为它合成一个。如果移动操作可能被定义为删除的函数，编译器就不会合成他们。

移动操作和合成的拷贝控制成员间还有最后一个相互作用关系:一个类是否定义了自己的移动操作对拷贝操作如何合成有影响。如果类定义了一个移动构造函数/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。

==Note:
定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认的被定义为删除的。==

### 移动右值，拷贝左值···
如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋制操作的情况类似。例如，在我们的StrVec类中，拷贝构造函数接受一个const StrVec的引用。因此，他可以用于任何可以转换为StrVec的类型。而移动构造函数接受一个StrVec&&,因此只能用于实参是(非static)右值的情形:

```c++
StrVec v1, v2;
v1 = v2;                   // v2是左值；使用拷贝赋值
StrVec getVec(istream &);  // getVec返回一个右值
v2 = getVec(cin);          // 使用移动赋值
```

在第一个赋值中，我们将v2传递给赋值运算符。v2的类型是StrVec，表达式v2是一个左值。因此移动版本的赋值运算符是不可行的，因为我们不能隐式的将一个右值引用绑定到一个左值。因此，这个赋值语句使用拷贝赋值运算符。

在第二个赋值中，我们赋予v2的是getVec的调用的结果。此表达式是一个右值。在此情况下，两个赋值运算符都是可行的————将getVec的结果绑定到两个运算符的参数都是允许的。调用拷贝赋值运算符需要进行一次到const的转换，而StrVec&&则是精确匹配。因此，第二个赋值使用移动赋值运算符。

### ···但如果没有移动构造函数，右值也被拷贝
如果一个类有一个拷贝构造函数但未定义移动构造函数，会发生什么呢？在此情况下，编译器不会合成移动构造函数，这意味着此类将有拷贝构造函数但不会有移动构造函数。如果一个类没有移动构造函数，函数匹配规则为保证该类型的对象将会被拷贝，即使我们试图通过调用move来移动它们时也是如此:

```c++
class Foo {
public:
    Foo() = default;
    Foo(const Foo&);  // 拷贝构造函数

};
Foo x;
Foo y(x);             // 拷贝构造函数；x是一个左值
Foo z(std::move(x));  // 拷贝构造函数；因为未定义移动构造函数
```

在对z进行初始化时，我们调用了move(x)，它返回一个绑定到x的Foo&&。Foo的拷贝构造函数是可行的，因为我们可以将一个Foo&&转换为一个const Foo&。因此，z的初始化将使用Foo使用的拷贝构造函数。

值得注意的是，用拷贝构造函数代替移动构造函数几乎肯定是安全的(赋值运算符的情况类似)。一般情况下，拷贝构造函数满足对应的移动构造函数的要求:它会拷贝给定对象，并将原对象至于有效状态。实际上，拷贝构造函数甚至都不会改变原对象的值。

==Note:
如果有一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来"移动"的。拷贝赋值运算符和移动运算符的情况类似。==

### 拷贝并交换赋值运算符和移动操作
我们的HasPtr版本定义了一个拷贝并交换赋值运算符，它是函数匹配和移动操作间相互关系的一个很好的示例。如果我们为此类添加一个移动构造函数，它实际上也会获得一个移动赋值运算符。

```c++
class HasPtr {
public:
    // 添加的移动构造函数
    HasPtr(HasPtr &&p) noexcept:ps(p.ps), i(p.i), {p.ps = 0; }
    // 赋值运算符既是移动赋值运算符也是拷贝赋值运算符
    HasPtr& operator= (HasPtr rhs) {
        swap(*this, rhs);
        return *this;
    }
};
```

在这个版本中，我们为类添加了一个移动构造函数，它接管了给定实参的值。构造函数体将给定的HasPtr的指针置为0，从而确保销毁移后源对象是安全的。此函数不会抛出异常，因此我们将其标记为noexcept。

现在让我们观察赋值运算符。此运算符有一个非引用参数，这意味此参数要进行拷贝初始化。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数————左值被拷贝，右值被移动。因此，单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能.

例如，假定hp和hp2都是HasPtr对象:

```c++
hp = hp2;  // hp2是一个左值；hp2通过拷贝构造函数来拷贝
hp = std::move(hp2);  // 移动构造函数移动hp2
```

在第一个赋值中，右侧运算对象是一个左值，因此移动构造函数是不可行的。rhs将使用拷贝构造函数来初始化。拷贝构造函数将分配一个新string，并拷贝hp2指向的string。

在第二个赋值中，我们调用std::move将一个右值引用绑定到hp2上。在此情况下，拷贝构造函数和移动构造函数都是可行的。但是，由于实参是一个右值引用，移动构造函数是精确匹配的。移动构造函数从hp2拷贝指针，而不会分配任何内存。

不管使用的是拷贝构造函数还是移动构造函数，赋值运算符的函数体都swap两个运算对象的状态。交换HasPtr会交换两个对象的指针(及int)成员。在swap之后,rhs中的指针将指向原来左侧运算对象所拥有的string。当rhs离开其作用域时，这个string将被销毁。

==建议:更新三五法则
所有五个拷贝控制成员应该看成一个整体；一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。如前所述，某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。==

### Message类的移动操作