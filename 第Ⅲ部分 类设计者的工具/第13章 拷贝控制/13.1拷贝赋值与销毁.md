# 13.1 拷贝、赋值与销毁
我们将以最基本的操作————拷贝构造函数、拷贝赋值运算符和析构函数作为开始。我们将在13.6节中介绍移动操作(C++11所引入的操作)。

## 13.1.1 拷贝构造函数
如果一个构造函数的第一个参数是自身类类型的引用,且任何额外参数都有默认值，则此构造函数是拷贝构造函数。

```c++
class Foo {
public:
    Foo();  // 默认构造函数
    Foo(const Foo&);  // 拷贝构造函数
};
```

拷贝构造函数的第一个参数必须是一个引用类型，原因我们稍后解释。虽然我们可以定义一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const的引用。拷贝构造函数在几种情况下都会被隐式地使用。因此，拷贝构造函数通常不应该是explicit的。

### 合成拷贝构造函数
如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。

对某些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象。而一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。

每个成员的类型决定了它如何拷贝: 对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。虽然我们不能直接拷贝一个数组，但合成拷贝构造函数会逐元素的拷贝一个数组类型的成员。如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝。

作为一个例子，我们Sales_data类的合成拷贝构造函数等价于:

```c++
class Sales_data {
public:
    Sales_data(const Sales_data&);
private:
    std::string bookNo;
    int units_sold = 0;
    double revenue = 0.0;
};


Sales_data::Sales_data(const Sales_data &orig) : 
bookNo(orig.bookNo),  // 使用string的拷贝构造函数
units_sold(orig.units_sold),  // 拷贝orig.units_sold
revenue(orig.revenue)  // 拷贝orig.revenue
{}  // 空函数体
```

### 拷贝初始化
现在，我们完全可以理解直接初始化和拷贝初始化之间的差异了:

```c++
string dots(10, ' .');  // 直接初始化
string s(dots);  // 直接初始化
string s2 = dots;  // 拷贝初始化
string null_book = "9-999-99999-9"  // 拷贝初始化
string nines = string(100, '9');  // 拷贝初始化
```

当使用直接初始化时，我们实际上时要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化(copy initialization)时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。

拷贝初始化通常使用拷贝构造函数来完成。但是，如果有一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。但现在，我们只需了解拷贝初始化何时发生，以及拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的就可以了。

拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生
> + 将一个对象作为实参残敌给一个非引用类型的形参
> + 从一个返回类型为非引用类型的函数返回一个对象
> + 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

某些类类型还会对他们所分配的对象使用拷贝初始化。例如，当我们呢初始化标准库容器或是调用其insert或push成员时，容器会对其元素进行拷贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化。

### 参数和返回值
在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。

拷贝构造函数被用来初始化非引用类类型的参数，这一特性解释了为什么拷贝构造函数自己参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功————为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。

### 拷贝初始化的限制
如前所述，如果我们使用的初始化值要求通过一个explicit的构造函数来进行类型转换，那么使用拷贝初始化还是直接初始化就不是无关紧要的了:

```c++
vector<int> v1(10);  // 正确，直接初始化
vector<int> v2 = 10;  // 错误，接受大小参数的构造函数是explict的
void f(vecotr<int>);  // f的参数进行拷贝初始化
f(10);  // 错误，不能用一个explicit的构造函数拷贝一个实参
f(vector<int>(10));  // 正确，从一个int直接构造一个临时vector
```

直接初始化v1是合法的，但看起来与其等价的拷贝初始化v2则是错误的，因为vector的接受单一大小参数的构造函数是explicit的。出于同样的原因，当传递一个实参或从函数返回一个值时，我们不能隐式使用一个explicit构造函数。如果我们希望使用一个explicit构造函数，就必须显式的使用，像此代码中最后一行那样。

### 编译器可以绕过拷贝构造函数
在拷贝初始化过程中，编译器可以(但不是必须)跳过拷贝/移动构造函数，直接创建对象。即，编译器被允许将下面的代码:

```c++
string null_book = "9-999-99999-9";  // 拷贝初始化
```

改写为

```c++
string null_book("9-999-99999-9");  // 拷贝初始化
```

但是，即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在且可访问的(例如，不能是private的)。

## 13.1.2 拷贝赋值运算符
与类控制其对象如何初始化一样，类也可以控制其对象如何赋值:

```c++
Sales_data trans, accum;
trans = accum;  // 使用Sales_data的拷贝赋值预算符
```

与拷贝构造函数一样，如果类未定义自己的拷贝构造运算符，编译器会为它合成一个。

### 重载赋值运算符
在介绍合成赋值运算符之前，我们需要了解一点有关重载运算符(overloaded operator)的知识。

重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为operator=的函数。类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。

重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。

拷贝赋值运算符接受一个与其所在类相同类型的参数；

```c++
class Foo {
public:
    Foo& operator= (const Foo&);  // 赋值运算符
};
```

为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。另外值得注意的是，标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。

**Best Practices: 赋值运算符通常应该返回一个指向其左侧运算对象的引用。**

### 合成拷贝赋值运算符
与处理拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符(synthesized copy-assignment operator)。类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值。如果拷贝赋值运算符并非出于此目的，它会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。

作为一个例子，下面的代码等价于Sales_data的合成拷贝赋值运算符:

```c++
Sales_data& Sales_data::operator=(const Sales_data &rhs) {
    bookNo = rhs.bookNo;  // 调用string::operator=
    units_sold = rhs.units_sold;  // 使用内置int赋值
    revenue = rhs.revenue;  // 使用内置的double赋值
    return *this;  // 返回一个此对象的引用
}
```

## 13.1.3 析构函数
析构函数执行与构造函数相反的操作:
构造函数初始化对象的非static数据成员，还可能做一些其他工作；
析构函数释放对象使用的资源，并销毁对象的非static数据成员。

析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数:

```c++
class Foo {
public:
    ~Foo();  // 析构函数
};
```

由于析构函数不接受参数，因此它不能被重载。对于一个给定类，只会有唯一一个析构函数。

### 析构函数完成什么工作

如同构造函数有一个初始化部分和一个函数体，析构函数也有一个函数体和一个析构部分。在一个析构函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化的顺序逆序销毁。

在对象最后一次使用之后，析构函数的函数体可执行类设计者希望执行的任何收尾工作。通常，析构函数释放对象在生存期分配的所有资源。

在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。

**Note:隐式销毁一个内置指针类型的成员不会delete它所指向的对象。**

与普通指针不同，智能指针是类类型，所以具有析构函数。因此，与普通指针不同，智能指针成员在析构阶段会被自动销毁。

### 什么时候会调用析构函数
无论何时一个对象被销毁，就会自动调用其析构函数:
> + 变量在离开作用域时被销毁。
> + 当一个对象被销毁时，其成员被销毁。
> + 容器(无论是标准库容器还是数组)被销毁时，其元素被销毁。
> + 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁。
> + 对于临时对象，当创建它的完整表达式结束时被销毁。

由于析构函数自动运行，我们的程序可以按需分配资源，而(通常)无需担心何时释放这些资源。

例如，下面代码片段定义了四个Sales_data对象:

```c++
{  // 新作用域
    // p和p2指向动态分配的对象
    Sales_data *p = new Sales_data;  // p是一个内置指针
    auto p2 = make_shared<Sales_data>();  // p2是一个shared_ptr
    Sales_data item(*p);  // 拷贝构造函数将*p拷贝到item中
    vector<Sales_data> vec;  // 局部对象
    vec.push_back(*p2);  // 拷贝p2指向的对象
    delete p;  // 对p指向的对象执行析构函数
}  // 推出局部作用域；对item, p2和vec调用析构函数
   // 销毁p2会递减其引用计数；如果引用计数变为0，对象被释放
   // 销毁vec会销毁它的元素
```

每个Sales_data对象都包含一个string成员，它分配动态内存来保存bookNo成员中的字符。但是，我们的代码唯一需要直接管理的内存就是我们直接分配的Sales_data对象。我们的代码只需要直接释放绑定到p的动态分配对象。

其他Sales_data对象会在离开作用域时被自动销毁。当程序块结束时，vec、p2和item都离开了作用域，意味着在这些对象上分别执行vector、shared_ptr和Sales_data的析构函数。

vector的析构函数会销毁我们添加到vector中的元素。
shared_ptr的析构函数会递减p2指向的对象的引用计数。在本例中，引用计数会变为0，因此shared_ptr的析构函数会delete p2分配的Sales_data对象。

在所有情况下，Sales_data的析构函数都会隐式的销毁bookNo成员。销毁bookNo会调用string的析构函数，它会释放用来保存ISBN的内存。

**Note:当指向一个对象的引用或指针离开作用域时，析构函数不会执行。**

### 合成析构函数
当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数。类似拷贝构造函数和拷贝赋值运算符，对于某些类，合成析构函数被用来阻止该类型的对象被销毁。如果不是这种情况，合成析构函数的函数体就为空。

例如，下面的代码片段等价于Sales_data的合成析构函数:

```c++
class Sales_data {
public:
    // 成员会被自动销毁，除此之外不需要做其他事情
    ~Sales_data() {}
};
```

在(空)析构函数体执行完毕后，成员会被自动销毁。特别的，string的析构函数会被调用，它将 释放bookNo成员所用的内存。

认识到析构函数体自身并不直接销毁成员是非常重要的。成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。