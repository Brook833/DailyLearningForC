# 13.3 交换操作
除了定义拷贝控制成员，管理资源的类通常还定义一个名为swap的函数。对于那些与重排元素顺序的算法一起使用的类，定义swap时非常重要的。这类算法在需要交换两个元素时会调用swap。

如果一个类定义了自己的swap，那么算法将使用类自定义版本。否则，算法将使用标准库定义的swap。虽然与往常一样我们不知道swap是如何实现的，但理论上很容易理解，为了交换两个对象我们需要进行一次拷贝和两次赋值。例如，交换两个类值HasPtr对象的代码可能像下面这样:

```c++
HasPtr temp = v1;  // 创建v1的值的一个临时副本
v1 = v2;  // 将v2的值赋予v1
v2 = temp;  // 将保存的v1的值赋予v2
```

这段代码将原来v1中的string拷贝了两次————第一次拷贝是HasPtr的拷贝构造函数将v1拷贝给temp，第二次是赋值运算符将temp赋予v2。将v2赋予v1的语句还拷贝了元来v2中的string。如果我们所见，拷贝一个类值的HasPtr会分配一个新string并将其拷贝到HasPtr指向的位置。

理论上，这些内存分配都是不必要的。我们更希望swap交换指针，而不是分配string的新副本。即，我们希望这样交换两个HasPtr:

```c++
string *temp = v1.ps;  // 为v1.ps中的指针创建一个副本
v1.ps = v2.ps;  // 为v2.ps中的指针赋予v1.ps
v2.ps = temp;  // 将保存的v1.ps中原来的指针赋予v2.ps
```

### 编写我们自己的swap函数
可以在我们的类上定义一个自己版本的swap来重载swap的默认行为。swap的典型实现如下:

```c++
class HasPtr {
    friend void swap(HasPtr&, HasPtr&);
};

inline void swap(HasPtr &lhs, HasPtr &rhs) {
    using std::swap;
    swap(lhs.ps, rhs.ps);  // 交换指针，而不是string数据
    swap(lhs.i, rhs.i);  // 交换int成员
}
```

我们首先将swap定义为friend，以便能访问HasPtr的(private的)数据成员。由于swap的存在就是为了优化代码，我们将其声明为inline函数。swap的函数体内对给定对象的每个数据成员调用swap。我们首先swap绑定到rhs和lhs的对象的指针成员，然后是int成员。

==Note:
与拷贝控制成员不同，swap并不是必要的。但是，对于分配了资源的类，定义swap可能是一种很重要的优化手段。==

### swap函数应该调用swap，而不是std::swap
此代码中有一个很重要的微妙之处:虽然这一点在这个特殊的例子中并不重要，但在一般情况下它非常重要————swap函数中调用的swap不是std::swap。在本例中，数据成员是内置类型的，而内置类型是没有特定版本的swap的，所以在本例中，对swap的调用会调用标准库std::swap。

但是如果一个类的成员有自己类型特定的swap函数，调用std::swap函数就是错误的了。例如，假定我们有另一个命名为Foo的类，它有一个类型为HasPtr的成员h。如果我们未定义Foo版本的swap,那么就会使用标准库版本的swap。如我们呢所见，标准库swap对HasPtr管理的string进行了不必须要的拷贝。

我们可以为Foo编写一个swap函数，来避免这些拷贝。但是，如果这样编写Foo版本的swap:

```c++
void swap(Foo &lhs, Foo &rhs) {
    // 错误，这个函数使用了标准库版本的swap，而不是HasPtr版本
    std::swap(lhs.h, rhs.h);
}
```

此代码会编译通过，且正常运行。但是，使用此版本与简单使用默认版本的swap并没有任何性能差异化。问题在于我们显式的调用了标准库版本的swap。但是，我们不希望使用std中的版本，我们希望调用为HasPtr对象定义的版本。

正确的swap函数如下所示:

```c++
void swap(Foo &lhs, Foo &rhs) {
    using std::swap;
    swap(lhs.h, rhs.h);  // 使用HasPtr版本的swap
}
```
每个swap调用应该都是未加限定的。即，每个调用都应该是swap，而不是std::swap。如果存在类型特定的swap版本，其匹配程度会优于std中定义的版本。因此，如果存在类型特定的swap版本，swap调用会与之匹配。如果不存在类型特定的版本，则会使用std中的版本。

### 在赋值运算符中使用swap
定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为拷贝并交换(copy and swap)的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换:

```c++
// 注意rhs是按值传递的，意味着HasPtr的拷贝构造函数
// 将右侧运算对象中的string拷贝到rhs
HasPtr& HasPtr::operator=(HasPtr rhs) {
    // 交换左侧运算对象和局部变量rhs的内容
    swap(*this, rhs);  // rhs现在指向本对象曾经使用的内存
    return *this;  // rhs被销毁，从而delete了rhs中的指针
}
```

在这个版本的赋值运算符中，参数并不是一个引用，我们将右侧运算对象以传值方式传递给了赋值运算符。因此，rhs是右侧运算对象的一个副本。参数传递时拷贝HasPtr的操作会分配该对象的string的一个新副本。

在赋值运算符的函数体中，我们调用swap来交换rhs和*this中的数据成员。这个调用将左侧运算对象中原来保存的指针存入rhs中，并将rhs中原来的指针存入 *this中。因此，在swap调用之后， *this中的指针成员将指向新分配的string————右侧运算对象中string的一个副本。

当赋值运算符结束时，rhs被销毁，HasPtr的析构函数将执行。此析构函数delete rhs现在指向的内存，即，释放掉原来左侧运算对象中的内存。

这个技术的有趣之处是它自动处理了自赋值情况且天然就是异常安全的。它通过在改变左侧运算对象之前拷贝右侧运算对象保证了自赋值的正确，这与我们在原来的赋值运算符中使用的方法是一致的。它保证异常安全的方法也与原来的赋值运算符实现一样。代码中唯一可能抛出异常的是拷贝构造函数中的new表达式。如果真发生了异常，它也会在我们改变左侧运算对象之前发生。

==Tip:
使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。==