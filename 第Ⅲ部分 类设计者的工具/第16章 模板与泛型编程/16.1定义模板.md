# 16.1 定义模板
假定我们希望编写一个函数来比较两个值，并指出第一个值是小于、等于还是大于第二个值。在实际中，我们可能想要定义多个函数，每个函数比较一种给定类型的值。我们的初次尝试可能定义多个重载函数,这两个函数几乎是相同的，唯一的差异是参数的类型，函数体则完全一样。

## 16.1.1 函数模板
我们可以定义一个通用的函数模板(function template)，而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare的函数模板可能像下面这样:

```c++
template <typename T>
int compare(const T &v1, const T &v2) {
    if (v1 < v2) {
        return -1;
    }
    if (v1 > v2) {
        return 1;
    }
    return 0;
}
```

模板定义以关键字template开始，后跟一个模板参数列表(template parameter list),这是一个逗号分隔的一个或多个模板参数(template parameter)的列表，用小于号(<)和大于号(>)包围起来。

==Note:
在模板定义中，模板参数列表不能为空。==

模板参数列表的作用很像函数参数列表。函数参数列表定义了若干特定类型的局部变量，但并未指出如何初始化它们。在运行时，调用者提供实参来初始化形参。

类似的，模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们(隐式的或显示的)指定模板实参，将其绑定到模板参数上。

我们的compare函数声明了一个名为T的类型参数。在compare中，我们用名字T表示一个类型。而T表示的实际类型则在编译时根据compare的使用情况来确定。

### 实例化函数模板
当我们调用一个函数模板时，编译器(通常)用函数实参来为我们推断模板实参。即，当我们调用compare时，编译器使用实参的类型来推断绑定到模板参数T的类型,例如:

```c++
cout << compare(1, 0) << endl;  // T为int
```

实参类型是int,编译器会推断出模板实参为int，并将它绑定到模板参数T。

编译器用推断出的模板来为我们实例化(instantiate)一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新“实例”。例如:

```c++
cout << compare(1, 0) << endl;  // T为int
vector<int> vec1{1, 2, 3}, vec2{4, 5, 6};
cout << compare(vec1, vec2) << endl;  // T为vector<int>
```

编译器会实例化出两个不同版本的compare。对于第一个调用，编译器会编写并编译一个compare版本，其中T被替换为int:

```c++
int compare(const int &v1, const int &v2) {
    /* */
}
```

对于第二个调用，编译器会生成另一个compare版本，其中T被替换为vector<int>。这些编译器生成的版本通常被称为模板的实例(instantiation)。