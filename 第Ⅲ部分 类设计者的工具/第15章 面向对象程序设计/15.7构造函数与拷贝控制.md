# 15.7 构造函数与拷贝控制
和其他类一样，位于继承体系中的类也需要控制其对象执行一系列操作时发生什么样的行为，这些操作包括创建、拷贝、移动、赋值和销毁。如果一个类(基类或派生类)没有定义拷贝控制操作，则编译器将为它合成一个版本。当然，这个合成版本也可以定义为被删除的函数。

## 15.7.1 虚析构函数
继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数，这样我们呢就能动态分配继承体系中的对象了。

如前所述，当我们delete一个动态分配的对象的指针时，将执行析构函数。如果该指针指向继承体系中的某个模型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。例如，如果我们delete一个Quote*类型的指针，则该指针可能实际指向了一个Bulk_quote类型的对象。如果是这样的话，编译器就必须清楚它应该执行的是Bulk_quote的析构函数。和其他函数一样，我们将通过在基类中将析构函数定义成虚析构函数以确保执行正确的析构函数版本:

```c++
class Quote {
public:
    virtual ~Quote() = default;  // 动态绑定析构函数
};
```

和其他虚函数一样，析构函数的叙述性也会被继承。因此，无论Quote的派生类使用合成的析构函数还是定义自己的析构函数，都将是虚析构函数。只要基类的析构函数是虚函数，就能确保我们delete基类指针时将运行正确的析构函数版本:

```c++
Quote *itemP = new Quote;   // 静态类型与动态类型一致
delete itemP;               // 调用Quote的析构函数
itemP = new Bulk_quote;     // 静态类型与动态类型不一致
delete itemP;               // 调用Bulk_quote的析构函数
```

**WARNING:如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。**

之前我们曾介绍过一条经验准则:一个类如果需要析构函数，那么它也同样需要拷贝和赋值操作。基类的析构函数并不遵循上述准则，他是一个重要的例外。一个基类总是需要析构函数，而且他能将析构函数设定为虚函数。此时，该析构函数为了成为虚函数而令内容为空，我们显然无法推断该基类是否还需要赋值运算符或拷贝构造函数。

### 虚析构函数将组织合成移动操作
基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响:如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。

## 15.7.2 合成拷贝控制与继承
基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数，赋值运算符或析构函数类似:他们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作:
> + 合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。
> + Quote的默认构造函数将bookNo成员默认初始化为空字符串，同时使用类内初始值将price初始化为0
> + Quote的构造函数完成后，继续执行Disc_quote的构造函数，他使用类内初始值qty和discount。
> + Disc_quote的构造函数完成后，继续执行Bulk_quote的构造函数，但是它是什么具体工作也不做。

值得注意的是，无论基类成员是合成的版本还是自定义的版本都没有太大影响。唯一的要求是相应的成员可访问，并且不是一个删除的函数。

对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类;该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。

Quote因为定义了析构函数而不能拥有合成的移动操作，因此当我们移动Quote对象时实际使用的是合成的拷贝操作，它的派生类也没有移动操作。

### 派生类中删除的拷贝控制与基类的关系
就像其他任何类的情况一样，基类或派生类也能出于同样的原因将其合成默认构造函数或者任何一个拷贝控制成员定义成被删除的函数。此外，某些定义基类的方式也可能导致有的派生类成员成为被删除的函数:
> + 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符是删除的或不可访问的，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作，
> + 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中生成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。
> + 编译器将不会合成一个删除掉的移动操作。当我们使用=default请求一个移动操作时，如果基类中对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。


```c++
class B {
public:
    B();
    B(const B&) = delete;
};

class D : public {};

D d;                  // 正确,D的合成默认构造函数使用B的默认构造函数
D d2(d);              // 错误,D的合成拷贝构造函数是被删除的
D d3(std::move(d));   // 错误,隐式的使用D的拷贝构造函数
```

基类B含有一个可访问的默认构造函数和一个显式删除的拷贝构造函数。因为我们定义了拷贝构造函数，所以编译器不会为B合成一个移动构造函数。因此，我们即不能移动也不能拷贝B的对象。如果B的派生类希望它自己的对象能被移动和拷贝，则派生类需要自定义相应版本的构造函数。当然。在这一过程中还必须拷贝如何移动或拷贝其基类部分的成员。在实际编程过程中，如果在基类没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作的。

### 移动操作与继承
因为基类缺少移动操作会组织派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中定义。我们的Quote可以使用合成的版本，不过前提是Quote必须显式的定义这些成员。一旦QUote定义了自己的移动操作，那么它必须同时显式定义拷贝操作:

```c++
class Quote {
public:
    Quote() = default;
    Quote(const Quote&) = default;
    Quote(Quote&&) = default;
    Quote& operate=(const Quote&) = default;
    Quote& operate=(Quote&&) = default;
    virtual ~Quote() = default;
};
```
## 15.7.3 派生类的拷贝控制成员
派生类构造函数再其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数再拷贝和移动自有成员时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。

和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。

对象的成员是被隐式销毁的；类似的，派生类对象的基类部分也是自动销毁的。

**WARNING: 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象**

### 定义派生类的拷贝或移动构造函数
当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分:
```c++
class Base{};
class D : public Base {
public:
    D(const D &d) : Base(d) {}    // 拷贝基类成员，使用的是Base的拷贝构造函数
    D(D&& d) : Base(std::move(d)) {}
};
```


```c++
D(const D& d) {}  // 使用的是Base的默认构造函数
```

**WARNING: 在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝(或移动)基类部分，则必须在派生类的构造函数初始值列表中显式的使用基类的拷贝(或移动)构造函数**

### 派生类赋值运算符
与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式的为其基类部分赋值:

```c++
// Base::operator=(const Base&)不会被自动调用
D& D::operator= (const D &rhs) {
    Base::operator=(rhs);  // 为基类部分赋值
    /* */
    return *this;
}
```

### 派生类析构函数
在析构函数体执行完成后，对象的成员会被隐式销毁。类似的，对象的基类部分也是隐式销毁的。因此，和构造函数和赋值运算符不同的是，派生类析构函数只负责销毁派生类自己分配的资源:

```c++
class D : public Base {
public:
    ~D(){/*该处由用户定义清楚派生类成员的操作*/}
};
```

对象的销毁顺序与其创建的顺序相反:派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后。

### 在构造函数和析构函数中调用虚函数
派生类对象的基类部分首先被创建。

当执行基类的构造函数时，该对象的派生类部分是未被初始化的状态。

类似的，销毁派生类对象的次序正好相反，因此当执行基类的析构函数时，派生类部分已经被销毁掉了。由此可知，当我们执行上述基类成员时，该对象处于未完成状态。

为了能够正确的处理这种未完成状态，编译器认为对象的类型在构造或析构的过程中仿佛发生了改变一样。也就是说，当我们构建一个对象时，需要把对象的类和构造函数的类看做是同一个。

这时虚函数可能会访问派生类的成员，毕竟，如果它不需要访问派生类成员的话，则派生类直接使用基类的虚函数就可以了。

然而，当执行基类构造函数时，它要用到的派生类成员尚未初始化，如果我们允许这样的访问，则程序很可能会崩溃。

==Note:
如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。==

## 15.7.4 集成的构造函数
在C++11中，派生类能够重用其直接基类定义的构造函数。尽管如我们所知，这些构造函数并非以常规的方式继承而来，但为了方便，我们姑且称其为"继承".
一个类只初始化它的基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，编译器将为派生类合成它们。

派生类继承基类构造函数的方式是提供了一条注明了(直接)基类名的using声明语句。举个例子，我们可以重新定义Bulk_quote类，令其继承Disc_quote类的构造函数:

```c++
class Bulk_quote : public Disc_quote {
public:
    using Disc_quote::Disc_quote;  // 继承Disc_quote的构造函数
    double net_price(std::size_t) const;
};
```

通常情况下，using声明语句只是某个名字在当前作用域可见。而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。

形如:

```c++
derived(parms) : base(args) {}
```

其中，derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将派生类构造函数的形参传递给基类的构造函数。

等价于:

```c++
Bulk_quote(const sring& book, double price, size_t qty, double disc) : Disc_quote(book, price, qty, disc) {}
```

如果派生类含有自己的数据成员，则这些成员将被默认初始化。

### 继承的构造函数特定
和普通成员的using声明不一样，一个构造函数的using声明不会改变该构造函数的访问级别。

而且，一个using声明语句不能指令explicit或constexpr。如果基类的构造函数是explicit或constexpr，则继承的构造函数也拥有相同的属性。
