# 15.7 构造函数与拷贝控制
和其他类一样，位于继承体系中的类也需要控制其对象执行一系列操作时发生什么样的行为，这些操作包括创建、拷贝、移动、赋值和销毁。如果一个类(基类或派生类)没有定义拷贝控制操作，则编译器将为它合成一个版本。当然，这个合成版本也可以定义为被删除的函数。

## 15.7.1 虚析构函数
继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数，这样我们呢就能动态分配继承体系中的对象了。

如前所述，当我们delete一个动态分配的对象的指针时，将执行析构函数。如果该指针指向继承体系中的某个模型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。例如，如果我们delete一个Quote*类型的指针，则该指针可能实际指向了一个Bulk_quote类型的对象。如果是这样的话，编译器就必须清楚它应该执行的是Bulk_quote的析构函数。和其他函数一样，我们将通过在基类中将析构函数定义成虚析构函数以确保执行正确的析构函数版本:

```c++
class Quote {
public:
    virtual ~Quote() = default;  // 动态绑定析构函数
};
```

和其他虚函数一样，析构函数的叙述性也会被继承。因此，无论Quote的派生类使用合成的析构函数还是定义自己的析构函数，都将是虚析构函数。只要基类的析构函数是虚函数，就能确保我们delete基类指针时将运行正确的析构函数版本:

```c++
Quote *itemP = new Quote;   // 静态类型与动态类型一致
delete itemP;               // 调用Quote的析构函数
itemP = new Bulk_quote;     // 静态类型与动态类型不一致
delete itemP;               // 调用Bulk_quote的析构函数
```

**WARNING:如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。**

之前我们曾介绍过一条经验准则:一个类如果需要析构函数，那么它也同样需要拷贝和赋值操作。基类的析构函数并不遵循上述准则，他是一个重要的例外。一个基类总是需要析构函数，而且他能将析构函数设定为虚函数。此时，该析构函数为了成为虚函数而令内容为空，我们显然无法推断该基类是否还需要赋值运算符或拷贝构造函数。

### 虚析构函数将组织合成移动操作
基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响:如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。

## 15.7.2 合成拷贝控制与继承
基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数，赋值运算符或析构函数类似:他们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作:
> + 合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。
> + Quote的默认构造函数将bookNo成员默认初始化为空字符串，同时使用类内初始值将price初始化为0
> + Quote的构造函数完成后，继续执行Disc_quote的构造函数，他使用类内初始值qty和discount。
> + Disc_quote的构造函数完成后，继续执行Bulk_quote的构造函数，但是它是什么具体工作也不做。

值得注意的是，无论基类成员是合成的版本还是自定义的版本都没有太大影响。唯一的要求是相应的成员可访问，并且不是一个删除的函数。

对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类;该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。

Quote因为定义了析构函数而不能拥有合成的移动操作，因此当我们移动Quote对象时实际使用的是合成的拷贝操作，它的派生类也没有移动操作。

### 派生类中删除的拷贝控制与基类的关系
就像其他任何类的情况一样，基类或派生类也能出于同样的原因将其合成默认构造函数或者任何一个拷贝控制成员定义成被删除的函数。此外，某些定义基类的方式也可能导致有的派生类成员成为被删除的函数:
> + 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符是删除的或不可访问的，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作，
> + 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中生成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。
> + 编译器将不会合成一个删除掉的移动操作。当我们使用=default请求一个移动操作时，如果基类中对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。


```c++
class B {
public:
    B();
    B(const B&) = delete;
};

class D : public {};

D d;                  // 正确,D的合成默认构造函数使用B的默认构造函数
D d2(d);              // 错误,D的合成拷贝构造函数是被删除的
D d3(std::move(d));   // 错误,隐式的使用D的拷贝构造函数
```

基类B含有一个可访问的默认构造函数和一个显式删除的拷贝构造函数。因为我们定义了拷贝构造函数，所以编译器不会为B合成一个移动构造函数。因此，我们即不能移动也不能拷贝B的对象。如果B的派生类希望它自己的对象能被移动和拷贝，则派生类需要自定义相应版本的构造函数。当然。在这一过程中还必须拷贝如何移动或拷贝其基类部分的成员。在实际编程过程中，如果在基类没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作的。

### 移动操作与继承
因为基类缺少移动操作会组织派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中定义。我们的Quote可以使用合成的版本，不过前提是Quote必须显式的定义这些成员。一旦QUote定义了自己的移动操作，那么它必须同时显式定义拷贝操作:

```c++
class Quote {
public:
    Quote() = default;
    Quote(const Quote&) = default;
    Quote(Quote&&) = default;
    Quote& operate=(const Quote&) = default;
    Quote& operate=(Quote&&) = default;
    virtual ~Quote() = default;
};
```
