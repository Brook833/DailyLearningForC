# 15.7 构造函数与拷贝控制
和其他类一样，位于继承体系中的类也需要控制其对象执行一系列操作时发生什么样的行为，这些操作包括创建、拷贝、移动、赋值和销毁。如果一个类(基类或派生类)没有定义拷贝控制操作，则编译器将为它合成一个版本。当然，这个合成版本也可以定义为被删除的函数。

## 15.7.1 虚析构函数
继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数，这样我们呢就能动态分配继承体系中的对象了。

如前所述，当我们delete一个动态分配的对象的指针时，将执行析构函数。如果该指针指向继承体系中的某个模型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。例如，如果我们delete一个Quote*类型的指针，则该指针可能实际指向了一个Bulk_quote类型的对象。如果是这样的话，编译器就必须清楚它应该执行的是Bulk_quote的析构函数。和其他函数一样，我们将通过在基类中将析构函数定义成虚析构函数以确保执行正确的析构函数版本:

```c++
class Quote {
public:
    virtual ~Quote() = default;  // 动态绑定析构函数
};
```

和其他虚函数一样，析构函数的叙述性也会被继承。因此，无论Quote的派生类使用合成的析构函数还是定义自己的析构函数，都将是虚析构函数。只要基类的析构函数是虚函数，就能确保我们delete基类指针时将运行正确的析构函数版本:

```c++
Quote *itemP = new Quote;   // 静态类型与动态类型一致
delete itemP;               // 调用Quote的析构函数
itemP = new Bulk_quote;     // 静态类型与动态类型不一致
delete itemP;               // 调用Bulk_quote的析构函数
```

**WARNING:如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。**

之前我们曾介绍过一条经验准则:一个类如果需要析构函数，那么它也同样需要拷贝和赋值操作。基类的析构函数并不遵循上述准则，他是一个重要的例外。一个基类总是需要析构函数，而且他能将析构函数设定为虚函数。此时，该析构函数为了成为虚函数而令内容为空，我们显然无法推断该基类是否还需要赋值运算符或拷贝构造函数。

### 虚析构函数将组织合成移动操作
基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响:如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。

## 15.7.2 合成拷贝控制与继承
基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数，赋值运算符或析构函数类似:他们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作:
> + 合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。
> + Quote的默认构造函数将bookNo成员默认初始化为空字符串，同时使用类内初始值将price初始化为0
> + Quote的构造函数完成后，继续执行Disc_quote的构造函数，他使用类内初始值qty和discount。
> + Disc_quote的构造函数完成后，继续执行Bulk_quote的构造函数，但是它是什么具体工作也不做。

值得注意的是，无论基类成员是合成的版本还是自定义的版本都没有太大影响。唯一的要求是相应的成员可访问，并且不是一个删除的函数。

对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类;该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。

Quote因为定义了析构函数而不能拥有合成的移动操作，因此当我们移动Quote对象时实际使用的是合成的拷贝操作，它的派生类也没有移动操作。

### 派生类中删除的拷贝控制与基类的关系
就像其他任何类的情况一样，基类或派生类也能出于同样的原因将其合成默认构造函数或者任何一个拷贝控制成员定义成被删除的函数。此外，某些定义基类的方式也可能导致有的派生类成员成为被删除的函数:
> + 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符是删除的或不可访问的，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作，
> + 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中生成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。
> + 编译器将不会合成一个删除掉的移动操作。当我们使用=default请求一个移动操作时，如果基类中对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。


```c++
class B {
public:
    B();
    B(const B&) = delete;
};

class D : public {};

D d;                  // 正确,D的合成默认构造函数使用B的默认构造函数
D d2(d);              // 错误,D的合成拷贝构造函数是被删除的
D d3(std::move(d));   // 错误,隐式的使用D的拷贝构造函数
```

基类B含有一个可访问的默认构造函数和一个显式删除的拷贝构造函数。因为我们定义了拷贝构造函数，所以编译器不会为B合成一个移动构造函数。因此，我们即不能移动也不能拷贝B的对象。如果B的派生类希望它自己的对象能被移动和拷贝，则派生类需要自定义相应版本的构造函数。当然。在这一过程中还必须拷贝如何移动或拷贝其基类部分的成员。在实际编程过程中，如果在基类没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作的。

### 移动操作与继承
因为基类缺少移动操作会组织派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中定义。我们的Quote可以使用合成的版本，不过前提是Quote必须显式的定义这些成员。一旦QUote定义了自己的移动操作，那么它必须同时显式定义拷贝操作:

```c++
class Quote {
public:
    Quote() = default;
    Quote(const Quote&) = default;
    Quote(Quote&&) = default;
    Quote& operate=(const Quote&) = default;
    Quote& operate=(Quote&&) = default;
    virtual ~Quote() = default;
};
```
## 15.7.3 派生类的拷贝控制成员
派生类构造函数再其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数再拷贝和移动自有成员时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。

和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。

对象的成员是被隐式销毁的；类似的，派生类对象的基类部分也是自动销毁的。

**WARNING: 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象**

### 定义派生类的拷贝或移动构造函数
当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分:
```c++
class Base{};
class D : public Base {
public:
    D(const D &d) : Base(d) {}    // 拷贝基类成员，使用的是Base的拷贝构造函数
    D(D&& d) : Base(std::move(d)) {}
};
```


```c++
D(const D& d) {}  // 使用的是Base的默认构造函数
```

**WARNING: 在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝(或移动)基类部分，则必须在派生类的构造函数初始值列表中显式的使用基类的拷贝(或移动)构造函数**

### 派生类赋值运算符
与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式的为其基类部分赋值:

```c++
// Base::operator=(const Base&)不会被自动调用
D& D::operator= (const D &rhs) {
    Base::operator=(rhs);  // 为基类部分赋值
    /* */
    return *this;
}
```

### 派生类析构函数
在析构函数体执行完成后，对象的成员会被隐式销毁。类似的，对象的基类部分也是隐式销毁的。因此，和构造函数和赋值运算符不同的是，派生类析构函数只负责销毁派生类自己分配的资源:

```c++
class D : public Base {
public:
    ~D(){/*该处由用户定义清楚派生类成员的操作*/}
};
```

对象的销毁顺序与其创建的顺序相反:派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后。

### 在构造函数和析构函数中调用虚函数
派生类对象的基类部分首先被创建。

当执行基类的构造函数时，该对象的派生类部分是未被初始化的状态。

类似的，销毁派生类对象的次序正好相反，因此当执行基类的析构函数时，派生类部分已经被销毁掉了。由此可知，当我们执行上述基类成员时，该对象处于未完成状态。

为了能够正确的处理这种未完成状态，编译器认为对象的类型在构造或析构的过程中仿佛发生了改变一样。也就是说，当我们构建一个对象时，需要把对象的类和构造函数的类看做是同一个。

这时虚函数可能会访问派生类的成员，毕竟，如果它不需要访问派生类成员的话，则派生类直接使用基类的虚函数就可以了。

然而，当执行基类构造函数时，它要用到的派生类成员尚未初始化，如果我们允许这样的访问，则程序很可能会崩溃。

==Note:
如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。==

## 15.7.4 集成的构造函数
在C++11中，派生类能够重用其直接基类定义的构造函数。尽管如我们所知，这些构造函数并非以常规的方式继承而来，但为了方便，我们姑且称其为"继承".
一个类只初始化它的基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，编译器将为派生类合成它们。

派生类继承基类构造函数的方式是提供了一条注明了(直接)基类名的using声明语句。举个例子，我们可以重新定义Bulk_quote类，令其继承Disc_quote类的构造函数:

```c++
class Bulk_quote : public Disc_quote {
public:
    using Disc_quote::Disc_quote;  // 继承Disc_quote的构造函数
    double net_price(std::size_t) const;
};
```

通常情况下，using声明语句只是某个名字在当前作用域可见。而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。

形如:

```c++
derived(parms) : base(args) {}
```

其中，derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将派生类构造函数的形参传递给基类的构造函数。

等价于:

```c++
Bulk_quote(const sring& book, double price, size_t qty, double disc) : Disc_quote(book, price, qty, disc) {}
```

如果派生类含有自己的数据成员，则这些成员将被默认初始化。

### 继承的构造函数特定
和普通成员的using声明不一样，一个构造函数的using声明不会改变该构造函数的访问级别。

而且，一个using声明语句不能指令explicit或constexpr。如果基类的构造函数是explicit或constexpr，则继承的构造函数也拥有相同的属性。

## 15.8 容器与继承
当我们使用容器存放继承体系中的对象时，通常必须采取间接存储的方式。因为不允许在容器中保存不同类型的元素，所以我们不能把具有继承关系的多种类型的对象直接存放在容器当中。

举个例子，假定我们想定义一个vector，令其保存用户准备购买的几种书籍。显然不应该用vector保存Bulk_quote对象，因为我们不能将Quote对象转换成Bulk_quote，所以我们将无法把Quote对象放置在该vector中。

其实，我们也不应该使用vector保存Quote对象。此时，虽然我们可以把Bulk_quote对象放置在容器中，但是这些对象再也不是Bulk_quote对象了:

```c++
vector<Quote> basket;
basket.push_back(Quote("0-201-52470-1", 50));
basket.push_back(Bulk_quote("0-201-54848-8", 50, 10, .25));  // 正确，但是只能把对象的Quote部分拷贝给basket
cout << basket.back().net_price(15) << endl;  // 调用Quote定义的版本，打印750，即15 * 50
```

basket的元素是Quote对象，因此当我们向该vector中添加一个Bulk_quote对象时，它的派生类部分将被忽略掉。

**WARNING:当派生类被赋值给基类对象时，其中的派生类部分将被"切掉",因此容器和存在继承关系的类型无法兼容**

### 在容器中放置(智能)指针而非对象
当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针(更好的选择是智能指针)。和往常一样，这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型:

```c++
vector<shared_ptr<Quote>> basket;
basket.push_back(make_shared<Quote>("0-201-82470-1", 50));
basket.push_back(make_shared<Bulk_quote>("0-201-54848-8", 50, 10, .25));
cout << basket.back()->net_price(15) << endl;
```

因为basket存放着shared_ptr，所以我们必须解引用basket.back()的返回值以获得运行net_price的对象。我们通过在net_price的调用中使用->已达到这个目的。如我们所知，实际调用的net_price版本依赖于指针所指对象的动态模型。

值得注意的是，我们将basket定义成shared_ptr<Quote>,但是在第二个push_back中传入的是一个bulk_quote对象的shared_ptr。

正如我们可以将一个派生类的普通指针转换成基类指针一样，我们也能吧一个派生类的智能指针转换成基类的智能指针。

make_shared<Bulk_quote>返回一个shared_ptr<Bulk_quote>对象，当我们调用push_back时，该对象被转换成shared_ptr<Quote>。因此尽管在形式上有所差别，但实际上basket的所有元素类型都是相同的。

## 15.8.1 编写Basket类
对于C++面向对象的编程来说，一个悖论时我们无法直接适用对象进行面向对象编程。相反，我们必须使用指针和引用。因为指针会增加程序的复杂性，所以我们经常定义一些辅助的类来处理这种复杂情况。首先，我们定义一个表示购物篮的类:

```c++
class Basket {
public:
    // Basket使用合成的默认构造函数和拷贝控制成员
    void add_item(const std::shared_ptr<Quote> &sale) {
        items.insert(sale);
    }

    double total_receipt(std::ostream&) const;
private:
    // 该函数用于比较shared_ptr
    static bool compare(const std::shared_ptr<Quote> &lhs, const std::shared_ptr<Quote> &rhs) {
        return lhs->isbn() < rhs->isbn();
    }
    std::multiset<std::shared_ptr<Quote>, decltype(compare) *>items{compare};
};
```

我们的类使用一个multiset来存放交易信息。这样我们就能保存同一本书的多条交易记录，而且对于一本给定的书籍，它的所有交易信息都保存在一起。

multiset的元素是shared_ptr。因为shared_ptr没有定义小于运算符，所以为了对元素排序我们必须提供自己的比较运算符。在此例中，我们定义了一个名为compare的私有静态成员，该成员负责比较shared_ptr所指的对象的isbn。我们初始化multiset，通过类内初始值调用比较函数:

```c++
std::multiset<std::shared_ptr<Quote>, decltype(compare)*>items{ compare };
```

定义了一个指向Quote对象的shared_ptr的multiset。这个multiset将使用一个与compare成员类型相同的函数来对其中的元素进行排序。multiset成员的名字是item，我们呢初始化item并令其使用我们的compare函数。

### 定义Basket的成员
Basktet类只定义两个操作。第一个成员是我们在类的内部定义的add_item成员，该成员接受一个指向动态分配的Quote的shared_ptr，然后将这个shared_ptr放置在multiset中。第二个成员的名字是total_receipt，它负责将购物篮的内容逐项打印成清单，然后返回购物篮中所有物品的总价格:

```c++
double Basket::total_receipt(ostream &os) const {
    double sum = 0.0;   // 保存实时计算出的总价格
    // iter指向ISBN相同的一批元素中的第一个
    // upper_bound返回一个迭代器，该迭代器指向这批元素的尾后位置
    for (auto iter = items.cbegin(); iter != items.cend(); iter = items.upper_bound(*iter)) {
        // 我们知道在当前的Basket中至少有一个该关键字的元素
        // 打印该书籍对应的项目
        sum += print_total(os, **iter, items,items.count(*iter));
    }
    os << "Total Sale: " << sum << endl;  // 打印最后的总价格
    return sum;
}
```

upper_bound()返回一个迭代器，该迭代器指向所有的与iter关键字相等的元素中最后一个元素的下一位置。因此，我们得到的迭代器或者指向end()，或者指向下一本书籍。

multiset的count成员统计在multiset中有多少元素的键值相同(即ISBN相同)。

如我们所知，print_tatal调用了虚函数net_price，因此最终的计算结果依赖于**iter的动态类型。

### 隐藏指针
Basket的用户仍然必须处理动态内存，原因是add_item需要接受一个shared_ptr参数。因此，用户不得不按照如下形式编写代码:

```c++
Basket bsk;
bsk.add_item(make_shared<Quote>("123", 45));
bsk.add_item(make_shared<Bulk_quote>("345", 45, 3, .15));
```

我们下一步是重新定义add_item，使得它接受一个Quote对象，而非shared_ptr。新版本的add_item将负责处理内存分配，这样他的用户就不必再受困于此了。我们将定义两个版本，一个拷贝它给定的对象，另一个则采取移动操作:

```c++
void add_item(const Quote& sale);
void add_Item(Quote &&sale);
```

唯一的问题是add_item不知道要分配的类型。当add_item进行内存分配时，它将拷贝(或移动)它的sale参数。在某处可能会有一条如下形式的new表达式:

```c++
new Quote(sale);
```

不幸的是，这条表达式所做的工作可能是不正确的:new为我们请求的类型分配内存，因此这条表达式将分配一个Quote类型的对象并且拷贝sale的Quote部分。然而，sale实际指向的可能是Bulk_quote对象，此时，该对象将被迫切掉一部分。

### 模拟虚拷贝
为了解决上述问题，我们给Quote类添加一个虚函数，该函数将申请一份当前对象的拷贝:

```c++
class Quote {
public:
    // 该虚函数返回当前对象的一份动态分配的拷贝
    virtual Quote* clone() const & { return new Quote(*this); }
    virtual Quote* clone() && { return new Quote(std::move(*this)); }
};

class Bulk_quote : public Quote {
    Bulk_quote *clone() const & { return new Bulk_quote(*this); }
    Bulk_quote *clone() && { return new Bulk_quote(std::move(*this)); }
};
```

因为我们拥有add_item的拷贝和移动版本，所以我们分别定义clone的左值和右值版本。每个clone函数分配当前类型的一个新对象，其中，const左值引用成员将他自己拷贝给新分配的对象;右值引用成员则将自己移动到新数据中。

我们可以使用clone很容易的写出新版本的add_item:

```c++
class Basket {
public:
    void add_item(const Quote &sale) { items.insert(std::shared_ptr<Quote>(sale.clone())); }
    void add_item(Quote &&sale) { items.insert(std::shared_ptr<Quote>(std::move(sale.clone()))); }
};
```

和add_item本身一样，clone函数也根据作用于左值和右值而分为不同的重载版本。在此例中，第一个add_item调用左值版本。
在右值版本中，尽管sale的类型是右值引用类型，但实际上sale本身(和任何其他变量一样)是个左值。因此，我们调用move把一个右值引用绑定到sale上。

我们的clone函数也是一个虚函数。sale的动态类型决定了到底运行Quote的函数还是Bulk_quote的函数。无论我们是拷贝还是移动数据，clone都返回一个新分配对象的指针，该对象与clone所属的类型一致。我们把一个shared_ptr绑定到这个对象上，然后调用insert将这个新分配的对象添加到items上。注意，因为，shared_ptr支持派生类向基类的类型转换，所以我们能把shared_ptr<Quote>绑定到Bulk_quote*上。