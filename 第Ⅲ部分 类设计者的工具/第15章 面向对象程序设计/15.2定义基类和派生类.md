# 15.2 定义基类和派生类
定义基类和派生类的方式在很多方面都与我们已知其他类的方式类似，但是也有一些不同之处。

## 15.2.1 定义基类
```c++
class Quote {
public:
    Quote() = default;
    Quote(const std::string &book, double sales_price) : bookNo(book), price(sales_price) {}
    
    strd::string isbn() const { return bookNo; }
    virtual double net_price(std::size_t n) const {
        return n * price
    }

    virtual ~Quote() = default;  // 对析构函数进行动态绑定

private:
    std::string bookNo;          // 书记的ISBN编号

protected:
    double price = 0.0;          // 代表普通状态下不打折的价格
};
```

对于上面这个类来说，新增的部分是在net_price函数和析构函数之前增加的virtual关键字以及最后的protected访问说明符。作为继承关系中根节点的类通常都会定义一个虚构函数。

==Note:
基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。==

### 成员函数与继承
派生类可以继承其基类的成员，然而当遇到如net_price这样与类型相关的操作时，派生类必须对其重新定义。换句话说，派生类需要对这些操作提供自己的新定义以覆盖(override)从基类继承而来的旧定义。

在C++语言中，基类必须将它的两种成员函数区分开来:一种是基类希望其派生类进行覆盖的函数;另一种是基类希望派生类直接继承而不要改变的函数。对于前者，基类通过将其定义成虚函数(virtual)。当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。

基类通过再起成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成与函数，则该类在派生类中隐式的也是虚函数。

成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。对于isbn成员来说这正是我们希望看到的结果。isbn函数的执行与派生类的细节无关，不管作用与Quote对象还是Bulk_quote对象，isbn函数的行为都一样。在我们的继承层关系中只有一个isbn函数，因此也就不存在调用isbn()时到底执行哪个版本的疑问。

### 访问与继承
派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问改成元，同时禁止其他用户访问。我们用受保护的(protected访问运算符说明这样的成员。

我们的Quote希望他的派生类定义各自的net_price函数，因此派生类需要访问Quote的price成员。此时我们将price定义成受保护的。与之相反，派生类访问bookNo成员的方式与其他用户是一样的，都是通过调用isbn函数，因此bookNo被定义成私有的，即使是Quote派生出来的类也不能直接访问它。

## 15.2.2 定义派生类
派生类必须通过类派生列表(class derivation list)明确指出它是从哪个(哪些)基类继承而来的。类派生列表的形式是:首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个:public, protected或者private。

派生类必须将其继承而来的成员函数中需要覆盖的哪些重新声明，因此，我们的Bulk_quote类必须包含一个net_price成员:

```c++
class Bulk_quote : public Quote {
public:
    Bulk_quote() = default;
    Bulk_quote(const std::string&, double, std::size_t, double);

    double net_price(std::size_t) const override;
private:
    std::size_t min_qty = 0;  // 适用折扣政策的最低购买量
    double discount = 0.0;    // 以小数表示的折扣额
};
```

我们的Bulk_quote类从它的基类Quote那里继承了isbn函数和bookNo，price等数据成员。此外，它还定义了net_price的新版本，同时拥有两个新增加的数据成员min_qty和discount。这两个成员分别用于说明享受折扣所需购买的最低数量以及一旦该数量达到之后具体的折扣信息。

访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见。

如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。此外，我们能将派生类型的对象绑定到基类的引用或指针上。因为我们在派生列表中使用了public,所以Bulk_quote的接口隐式的包含isbn函数，同时在任何需要Quote的引用或指针的地方我们都能使用Bulk_quote的对象。

大多数类都只继承一个类，这种形式的继承被称作"单继承"。

### 派生类中的虚函数
派生类经常(但不总是)覆盖继承它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。

派生类可以在它覆盖的函数前使用virtual关键字，但不是非得这么做。C++新标准允许派生类显式的注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的关键字const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字override。

### 派生类对象及派生类向基类的类型转换
一个派生类对象包含多个组成部分:一个含有派生类自己定义的(非静态)成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。因此，一个Bulk_quote对象将包含四个数据元素:它从Quote继承而来的BookNo和price数据成员，以及Bulk_quote自己定义的min_qty和discount成员。

C++标准并没有明确规定派生类的对象在内存中如何分布，但是我们可以认为Bulk_quote的对象包含两部分。

|  | Bulk_quote对象 |
|:- |:- |
| 从Quote继承而来的成员 | bookNo price |
| Bulk_quote自定义的成员 | min_qty discount |

**在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的**

因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。

```c++
Quote item;        // 基类对象
Bulk_quote bulk;   // 派生类对象
Quote *p = &item;  // p指向Quote对象
p = &bulk;         // p指向bulk的Quote部分
Quote &r = bulk;   // r绑定到bulk的Quote部分
```

这种转换通常称为派生类到基类的(derived-to-base)类型转换。和其他类型转换一样，编译器会隐式的执行派生类到基类的转换。

这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；同样的，我们也可以把派生类对象的指针用在需要基类指针的地方。

==Note:
在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在==

### 派生类构造函数
