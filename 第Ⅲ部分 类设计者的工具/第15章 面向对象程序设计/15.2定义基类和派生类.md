# 15.2 定义基类和派生类
定义基类和派生类的方式在很多方面都与我们已知其他类的方式类似，但是也有一些不同之处。

## 15.2.1 定义基类
```c++
class Quote {
public:
    Quote() = default;
    Quote(const std::string &book, double sales_price) : bookNo(book), price(sales_price) {}
    
    strd::string isbn() const { return bookNo; }
    virtual double net_price(std::size_t n) const {
        return n * price
    }

    virtual ~Quote() = default;  // 对析构函数进行动态绑定

private:
    std::string bookNo;          // 书记的ISBN编号

protected:
    double price = 0.0;          // 代表普通状态下不打折的价格
};
```

对于上面这个类来说，新增的部分是在net_price函数和析构函数之前增加的virtual关键字以及最后的protected访问说明符。作为继承关系中根节点的类通常都会定义一个虚构函数。

==Note:
基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。==

### 成员函数与继承
派生类可以继承其基类的成员，然而当遇到如net_price这样与类型相关的操作时，派生类必须对其重新定义。换句话说，派生类需要对这些操作提供自己的新定义以覆盖(override)从基类继承而来的旧定义。

在C++语言中，基类必须将它的两种成员函数区分开来:一种是基类希望其派生类进行覆盖的函数;另一种是基类希望派生类直接继承而不要改变的函数。对于前者，基类通过将其定义成虚函数(virtual)。当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。

基类通过再起成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成与函数，则该类在派生类中隐式的也是虚函数。

成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。对于isbn成员来说这正是我们希望看到的结果。isbn函数的执行与派生类的细节无关，不管作用与Quote对象还是Bulk_quote对象，isbn函数的行为都一样。在我们的继承层关系中只有一个isbn函数，因此也就不存在调用isbn()时到底执行哪个版本的疑问。

### 访问与继承
派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问改成元，同时禁止其他用户访问。我们用受保护的(protected访问运算符说明这样的成员。

我们的Quote希望他的派生类定义各自的net_price函数，因此派生类需要访问Quote的price成员。此时我们将price定义成受保护的。与之相反，派生类访问bookNo成员的方式与其他用户是一样的，都是通过调用isbn函数，因此bookNo被定义成私有的，即使是Quote派生出来的类也不能直接访问它。

## 15.2.2 定义派生类
派生类必须通过类派生列表(class derivation list)明确指出它是从哪个(哪些)基类继承而来的。类派生列表的形式是:首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个:public, protected或者private。

派生类必须将其继承而来的成员函数中需要覆盖的哪些重新声明，因此，我们的Bulk_quote类必须包含一个net_price成员:

```c++
class Bulk_quote : public Quote {
public:
    Bulk_quote() = default;
    Bulk_quote(const std::string&, double, std::size_t, double);

    double net_price(std::size_t) const override;
private:
    std::size_t min_qty = 0;  // 适用折扣政策的最低购买量
    double discount = 0.0;    // 以小数表示的折扣额
};
```

我们的Bulk_quote类从它的基类Quote那里继承了isbn函数和bookNo，price等数据成员。此外，它还定义了net_price的新版本，同时拥有两个新增加的数据成员min_qty和discount。这两个成员分别用于说明享受折扣所需购买的最低数量以及一旦该数量达到之后具体的折扣信息。

访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见。

如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。此外，我们能将派生类型的对象绑定到基类的引用或指针上。因为我们在派生列表中使用了public,所以Bulk_quote的接口隐式的包含isbn函数，同时在任何需要Quote的引用或指针的地方我们都能使用Bulk_quote的对象。

大多数类都只继承一个类，这种形式的继承被称作"单继承"。

### 派生类中的虚函数
派生类经常(但不总是)覆盖继承它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。

派生类可以在它覆盖的函数前使用virtual关键字，但不是非得这么做。C++新标准允许派生类显式的注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的关键字const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字override。

### 派生类对象及派生类向基类的类型转换
一个派生类对象包含多个组成部分:一个含有派生类自己定义的(非静态)成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。因此，一个Bulk_quote对象将包含四个数据元素:它从Quote继承而来的BookNo和price数据成员，以及Bulk_quote自己定义的min_qty和discount成员。

C++标准并没有明确规定派生类的对象在内存中如何分布，但是我们可以认为Bulk_quote的对象包含两部分。

|  | Bulk_quote对象 |
|:- |:- |
| 从Quote继承而来的成员 | bookNo price |
| Bulk_quote自定义的成员 | min_qty discount |

**在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的**

因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。

```c++
Quote item;        // 基类对象
Bulk_quote bulk;   // 派生类对象
Quote *p = &item;  // p指向Quote对象
p = &bulk;         // p指向bulk的Quote部分
Quote &r = bulk;   // r绑定到bulk的Quote部分
```

这种转换通常称为派生类到基类的(derived-to-base)类型转换。和其他类型转换一样，编译器会隐式的执行派生类到基类的转换。

这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；同样的，我们也可以把派生类对象的指针用在需要基类指针的地方。

==Note:
在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在==

### 派生类构造函数
尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类必须使用基类的构造函数来初始化它的基类部分。

==Note:
每个类控制它自己的成员初始化过程。==

派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作的。类似于我们初始化成员的过程，派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的。例如，接受四个参数的Bulk_quote构造函数如下所示:

```c++
Bulk_quote(const string& book, double p, size_t qty, double disc) : Quote(book,p), min_qty(qty), discount(disc) {}
```

该函数将他的前两个参数(分别表示ISBN和价格)传递给Quote的构造函数，由Quote的构造函数负责初始化Bulk_quote的基类部分(即bookNo成员和price成员)。当(空的)Quote构造函数体结束后，我们构建的对象的基类部分也就完成了。接下来初始化由派生类直接定义的min_qty成员和discount成员。最后运行Bulk_quote构造函数的(空的)函数体。

除非我们特别之处，否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。这些实参将帮助编译器决定到底选用哪个构造函数来初始化派生类对象的基类部分。

==Note:
首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。==

### 派生类使用基类的成员
派生类可以访问基类的公有成员和受保护成员:

```c++
double Bule_quote::net_price(size_t cnt) const {
    if (cnt >= min_qty) {
        return cnt * (1 - discount) * price;
    } else {
        return cnt * price;
    }
}
```

该函数产生一个打折后的价格:如果给定的数量超过了min_qty，则将discount(一个小于1大于0的数)作用于price。

目前只需要了解派生类的作用域嵌套在基类的作用域之内。因此，对于派生类的一个成员来说，使用派生类成员的方式和使用基类成员的方式没什么不同。

==关键概念:遵循基类的接口
必须明确一点:每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。
因此，派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。==

### 继承与静态成员
如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。

```c++
class Base {
public:
    static void statmem();
};

class Derivec : public Base {
    void f(const Dericed&);
}
```

静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它:

```c++
void Derived::f(const Derived &derived_obj) {
    Base::statmem();     // 正确，Base定义了statmem
    Derived::statmem();  // 正确，Derived继承了statmem
    derived_obj.statmem();  // 通过Derived对象访问
    statmem();              // 通过this对象访问
}
```

### 派生类的声明
派生类的声明与其他类差别不大，声明中包含类名但是不包含它的派生列表:

```c++
class Bulk_quote : public Quote;  // 错误,派生列表不能出现在这里
class Bulk_quote;  // 正确，声明派生类的正确方式
```

一条声明语句的目的是令程序知晓某个名字的存在以及该名字表示一个什么样的实体，如一个类，一个函数或一个变量等。派生列表以及定义有关的其他细节必须与类的主题一起出现。

### 被用作基类的类
如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明:

```c++
class Quote;    //声明但未定义
// 错误，Quote必须被定义
class Bulk_quote : public Quote {};
```

这一规定的原因显而易见，派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。因此该规定还有一层隐含的意思，即一个类不能派生它本身。

一个类是基类，同时它也可以是一个派生类:

```c++
class Bass {};
class D1 : public Base {};
class D2 : public D1 {};
```

在这个继承关系中，Base是D1的直接基类(direct base)，同时是D2的间接基类(indirect base)。直接基类出现在派生列表中，而间接基类通过其直接基类继承而来。

每个类都会继承直接基类的所有成员。对于一个最终的派生类来说，他会继承其直接基类的成员:该直接基类的成员又含有其基类的成员:依次类推直至继承链的顶端。因此，最中的派生类将包含它的直接基类的子对象记忆每个间接基类的子对象。

### 防止继承的繁盛
有时我们会定义这样一种类，我们不希望其他类继承他，或者不想考虑它是否适合作为一个基类。为了实现这一目的，C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final:

```c++
class NoDerived final {};    // NoDerived不能作为基类
class Base {};
// Last是final的，我们不能继承Last
class Last final : Base {};  // Last不能作为基类
class Bad : NoDerived {};    // 错误，NoDerived是final的
class Bad2 : Last {};        // 错误, Last是final的。
```

## 15.2.3 类型转换与继承
**WARNING: 理解基类和派生类之间的类型转换是理解C++语言面对对象编程的关键所在**

通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针类型应与对象的类型一致，或者对象的类型含有一个可接受的const类型转换规则。存在继承关系的类是一个重要的例外；==我们可以将基类的指针或引用绑定到派生类对象上==。例如，我们可以用Quote&指向一个Bulk_quote对象，也可以把一个Bulk_quote对象的地址赋给一个Quote*。

可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义:当使用基类的引用(或指针)时，实际上我们并不清楚该引用(或指针)所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。

==Note:和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能之类内。==

### 静态类型与动态类型
当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型(static type)与该表达式表示对象的动态类型(dynamic type)区分开来。表达式的静态类型在编译时总是已知的，它时变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。动态类型知道运行时才可知。

例如，当print_total调用net_price时:

```c++
double ret = item.net_price(n);
```

我们知道item的静态类型是Quote&,它的动态类型则依赖于item绑定的实参，动态类型直到运行时调用该函数时才会知道。如果我们传递一个Bulk_quote对象给print_total，则item的静态类型将与它的动态类型不一致。如前所述，item的静态类型是Quote&,而在此例中它的动态类型是Bulk_quote。

如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。例如，Quote类型变量永远是一个Quote对象，我们无论如何都不能改变该变量对应的对象的类型。

==Note:
基类的指针或引用的静态类型可能与其动态类型不一致，读者一定要理解其中的原因。==

### 不存在从基类向派生类的隐式类型转换···
之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上。一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在。如果基类对象不是派生类对象的一部分，则它只含有基类定义的成员，而不含有派生类定义的成员。

因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类向派生类的自动类型转换:

```c++
Quote base;
Bulk_quote* bulkP = &base;    // 错误，不能将基类转换成派生类
Bulk_quote& bulkRef = base;   // 错误，不能将基类转换成派生类
```

如果上述赋值是合法的，则我们可能会使用bulkP或bulkRef访问base中不存在的成员。

除此之外还有一种情况显得有点特别，即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换:

```c++
Bulk_quote bulk;
Quote *itemP = &bulk;  // 正确，动态类型是Bulk_quote
Bulk_quote *bulkP = itemP;  // 错误，不能将基类转换成派生类
```

编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。如果在基类中含有一个或多个虚函数，我们可以使用dynamic_cast请求一个类型转换，该转换的安全检查将在运行时执行。同样，如果我们已知某个基类向派生类的转换是安全的，则我们可以使用static_cast来强制覆盖掉编译器的检查工作。

### ···在对象之间不存在类型转换
派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。很多时候，我们确实希望将派生类对象转换成它的基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别。

请注意，当我们初始化或赋值一个类类型的对象时，实际上是在调用某个函数。当执行初始化时，我们调用构造函数；而当会执行赋值操作时，我们调用赋值运算符。这些成员通常都包含一个参数，该参数的类型是类类型的const版本引用。

因为这些成员接受引用作为参数，所以派生类向基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象。这些操作不是虚函数。当我们给基类的构造函数传递一个派生类对象时，实际运行的构造函数是基类中定义的那个，显然该构造函数只能处理基类自己的成员。类似的，如果我们将一个派生类对象赋值给一个基类对象，则实际运行的赋值运算符也是基类中定义的那个，该运算符同样只能处理基类自己的成员。

例如，我们的书店类实用类合成版本的拷贝和赋值操作:

```c++
Bulk_quote bulk;    // 派生类对象
Quote item(bulk);   // 使用Quote::Quote(cosnt Quote&)构造函数
item = bulk;        // 使用Quote::operator= (const Quote&)
```

当构造item时，运行Quote的拷贝构造函数。该函数只能处理bookNo和price两个成员，它负责bulk中Quote部分的成员，同时忽略掉bulk中Bulk_quote部分的成员。类似的，对于将bulk赋值给item的操作来说，只有bulk和Quote部分的成员被赋值给item。

因为在上述过程中会忽略Bulk_quote部分，所以我们可以说bulk的Bulk_quote部分被切掉了(sliced down)。

**WARNING:当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。**

==关键概念:存在继承关系的类型之间的转换规则
要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要:==
> + 从派生类向基类的类型转换只对指针或引用类型有效
> + 基类向派生类不存在隐式类型转换
> + 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。

==尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然(显式或隐式的)定义了拷贝控制成员。因此，我们能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意的是，这种操作只处理派生类对象的基类部分。派生类部分被切掉了。==

==大的向小的类型转换，只能是指针或引用类型==
==小的向大的类型转换，只能显式dyanmic_cast==