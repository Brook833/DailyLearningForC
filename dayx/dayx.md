2022.11.22



## 10.2 初识泛型算法
标准库提供了超过100多个算法。幸运的是，与容器类似，这些算法有一致的结构性。比起死记硬背100多个算法，理解此结构可以帮助我们更容易的学习和使用这些算法。本章中，我们将展示如何使用这些算法，并介绍刻画这些算法的统一原则。附录A按操作方式列出了所有的算法。

除了少数例外，标准库算法都是对一个范围内的元素进行操作。我们将此元素范围成为”输入范围“。接受输入范围的算法总是使用前两个参数来表示此范围，两个参数分别是指向要处理的第一个元素和尾后迭代器。

虽然大多数算法遍历输入范围的方式相似，但他们使用范围中元素的方式不同。理解算法最基本的方法就是它们是否读取元素、改变元素或是重排元素顺序。

## 10.2.1 只读算法
一些算法只会读取器输入范围内的元素，而从不改变元素。find就是这样一种算法，count也是如此。

另一个值算法是accumulate，它定义在numeric中。accumulate函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值。假定vec是一个整数序列:

```c++
int sum = accumulate(vec.cbegin(), vec.cedn(), 0);
```

这条语句将sum设置为vec中元素的和，和的初值为0。

**Note: accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。**

### 算法和元素类型
accumulate将第三个参数作为求和起点，这蕴含着一个编程假定:将元素类型加到求和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。在上例中，vec中的元素可以是int，double，long long或任何可以加到int上的类型。

下面是一个例子，由于string定义了+运算符，所以我们可以通过调用accumulate来将vector中所有string元素连接起来:

```c++
string sum = accumulate(v.cbegin(), v.cend(), string(""));
```

此调用将v中每个元素连接到一个string上，该string初始时为空串。注意，我们通过第三个参数显式的创建了一个string。将空串当做一个字符串字面值传递给第三个参数是不可以的，会导致一个编译错误。

```c++
// 错误，const char * 上没有定义+运算符
string sum = accumulate(v.cbegin(), v.cend(), " ");
```

原因在于，如果我们传递了一个字符串字面值，用于保存和的对象的类型将是const char*。如前所述，此类型决定了使用哪个+运算符。由于const char*并没有+运算符，此调用将产生编译错误。

### 操作两个序列的算法
另一个只读算法是equal，用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回true，否则返回false。此算法接受三个迭代器:前两个(与往常一样)表示第一个序列中的元素范围，第三个表示第二个序列中的首元素:

```c++
// roster2中的元素数目应该至少与roster1一样多
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
```

由于equal利用迭代器完成操作，因此我们可以通过调用equal来比较两个不同类型容器中的元素、而且，元素类型也不必一样，只要我们能用==来比较两个元素类型即可。例如，在此例中，roster1可以是vector<int>，而roster2是list<const char*>。

但是，equal基于一个非常重要的假设:它假定第二序列至少与第一个序列一样长。此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素。

**WARNING: 那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长**

