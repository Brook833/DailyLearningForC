2022.9.10
复习C++primer 2.4const限定符

## const限定符
const对象必须初始化，初始值可以是任意复杂的表达式。

##  默认状态下，const对象仅在文件内有效。

当以编译时初始化的方式定义一个const对象时，编译器将在编译过程中用到该变量的值都替换成对应的值，为了执行上述替换，编译器必须知道变量的值，如果程序包含多个文件，则每个文件用了const对象的文件都能访问到他的初始值才行。要做到这一点，就必须在每个用到的文件中都有对它的定义。同时避免对同一变量的重复定义，默认情况下const对象仅在文件内生效。当多个文件中出现同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。

解决办法是，对于const变量不管是声明还是定义，都添加extern关键字，这样仅需要定义一次。

## const的引用
可以把引用绑定到const对象上，就像绑定到其他对象上一样。称之为对常量的引用。对常量的引用不能被用作修改她所绑定的对象。

常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。

int i = 42;
int &r1 = i;
const int &r2 = i;
r1 = 0;
r2 = 0; //错误，r2是一个常量引用。

## 指针和const
指向常量的指针不能用于改变其所指的对象的值。要想存放常量对象的地址，只能使用指向常量的指针。

指向常量的指针也没有规定所指的对象必须是一个常量。

double dval = 3.14

cptr = &dval;

#

常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能在改变了。把*放在const关键字之前用以说明指针是一个常量，不变的时指针本身的值而非指向的那个值。

int errNumb = 0;

int *const curErr = &errNumb; //curErr将一直指向errNub;

const double pi = 3.1415;

const double *const pip = &pi; //pip是一个指向常量对象的常量指针 

## 顶层const
指针本身是一个对象，他又可以指向另外一个对象，因此，指针本身是不是常量以及指针所指的是不是一个常量，是两个相互独立的问题。

顶层const表示指针本身是一个常量。（不能改变指针的指向 int *const p)

底层const表示指针所指的对象时一个常量。(不能通过该指针改变被指对象的值 const int *p)

更一般的，顶层const可以表示任意的对象是常量，对任何数据类型都适用，如算数类型，类，指针等。

底层const则与指针和引用等复合类型的基本类型部分有关。

指针类型既可以是顶层const也可以是底层const。

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响；但底层const的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的const资格，或者两个对象的数据类型必须能能够转换，一般来说，非常量可以转换成常量，反之则不行。即（const int = int; const int = const int)

## constexpr和常量表达式
常量表达式(const expression)是指不会改变并且在编译过程中就能得到计算结果的表达式。

字面值属于常量表达式；

用常量表达式初始化的const对象也是常量表达式。 

C++11新标准规定，允许将变量声明为constexpr类型以便编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。

算数类型，引用，指针都属于字面值类型。自定义类，IO库，string类型则不属于字面值类型，也就不能被定义成constexpr。

一个constexpr指针的初始值必须是nullptr或者0,或者时存储某个固定地址中的对象。 

函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义域所有函数体制外的对象其地址固定不变，能用来初始化constexpr指针。

constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，预期所指的对象无关。与顶层const相同。