2022.11.03



## IO库
C++语言不直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO。这些类型支持从设备读取数据、向设备写入数据的IO操作，设备可以是文件、控制台窗口等。还有一些类型允许内存IO，机，从string读取数据，向string写入数据。

IO库定义了读写内置类型值的操作。此外，一些类，如string，通常也会定义类似的IO操作，来读写自己的对象。

### IO类
到目前为止，我们已经使用过的IO类型和对象都是操纵char数据的。默认情况下，这些对象都是关联到用户的控制台窗口。当然，我们不能限制实际应用程序仅从控制台窗口进行IO操作，应用程序常常需要读写命名文件。而且，使用IO操作处理string中的字符会很方便。此外，应用程序还可能读写需要宽字符支持的语言。

为了支持这些不同种类的IO处理操作，在istream和ostream之外，标准库还定义了其他一些IO类型，我们之前都已经使用过了。下表列出了这些类型，分别定义在三个独立的头文件中：iostream定义了用于读写流的基本类型，fstream定义了读写命名文件的类型，sstream定义了读写内存string对象的类型。

iostream  从流读取写入数据

fstream   从文件读取写入数据

sstream   从string读取写入数据

为了支持使用宽字符的语言，标准库定义了一组类型和对象操纵wchar_t类型的数据。宽字符版本的类型和函数以w开始。例如，wcin、wcout、和wcerr是分别对应cin、cout和cerr的宽字符 版本对象。宽字符版本的类型和对象与其对应的普通char版本的类型定义在同一个头文件中。例如，头文件fstrean定义了ifstream和wifstream类型。

### IO类型间的关系
概念上，设备类型和字符大小都不会影响我们要执行的IO操作。例如，我们可以用>>读取数据，而不用管是从一个控制台窗口，一个磁盘文件，还是一个string读取。类似的，我们也不用管读取的字符能存入一个char对象内，还是需要一个wchar_t对象来存储。

标准库使我们能忽略这些不同类型的流之间的差异，这是通过继承机制实现的。利用模板，我们可以使用具有继承关系的类，而不必了解继承机制如何工作的细节。

简单地说，继承机制使我们可以声明一个特定的类继承自另一个类。我们通常可以将一个派生类(继承类)对象当作其基类(所继承的类)对象来使用。

类型ifstream和istringstream都继承自istream对象。也就是说，我们是如何使用cin的，就可以同样地使用这些类型的对象。例如，可以对一个ifstream或istringstream对象调用getline，也可以使用>>从一个ifstream或istringstream对象中读取数据。

Note:

本节剩下部分所介绍的标准库流特性都可以无差别的应用于普通流、文件流和string流，以及char或宽字符流版本。

### IO对象无拷贝或赋值
我们不能拷贝或对IO对象赋值：

```c++
ofstream out1 out2;
out1 = out2;  //错误:不能对流对象赋值
ofstream print(ofstream);  //错误：不能初始化ofstream参数
out2 = print(out2);  //错误:不能拷贝流对象
```

由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。

### 条件状态
IO操作一个与生俱来的问题是可能发生错误的。一些错误是可恢复的，而其他错误则发生在系统深处，已经超出了应用程序可以修正的范围。下标列出了IO类所定义的一些函数和标志，可以帮助我们访问和操纵流的条件状态。

strm::iostate  strm是一种IO类型，iostate是一种机器相关的类型，提供了表达条件状态的完整功能

strm::badbit   strm::badbit用来指出流已崩溃

strm::failbit  strm::failbit用来指出一个IO操作失败了

strm::eofbit   strm::eofbit用来指出流到达了文件结束

strm::goodbit  strm::goodbit用来指出流为处于错误状态。此值保证为零。

下面是一个IO错误的例子:

```c++
int ival;
cin >> ival;
```

如果我们在标准输入上键入Boo，读操作就会失败。代码中的输入运算符读取一个int，但却得到了一个字符B。这样，cin会进入错误状态。类似的，如果我们输入一个文件结束标识，cin也会进入错误状态。

一个流一旦发生错误，其上后续的IO操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据，向它写入数据。由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用:

```c++
while(cin >> word)
    //ok:读操作成功
```

while循环检查 >> 表达式返回的流的状态。如果输入操作成功，流保持有效状态，则条件为真。

### 查询流的状态
将流作为条件使用，只能告诉我们流是否有效，而无法告诉我们具体发生了什么。有时我们也需要知道流为什么失败。例如，在键入文件结束标识符后我们的应对措施，可能与遇到一个IO设备错误的处理方式是不同的。

IO库定义了一个与机器无关的iostate类型，它提供了表达流状态的完整功能。这个类型应作为一个位集合来使用，提供了表达流状态的完整功能。可以一次性检测或设置多个标志位。

badbit表示系统级错误，如不可恢复的读写错误。通常情况下，一旦badbit被置位，流就无法再使用了。在发生可恢复错误后，failbit被置位，如期望读取数值却读出一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。如果到达文件结束位置，eofbit和failbit都会被置位。goodbit的值位0，表示流未发生错误。如果badbit、failbit和eofbit人一个被置位，则检测流状态的条件会失败

标准库还定义了一组函数来查询这些标志位的状态。操作good在所有错误位均未置为的情况下返回true，而Bad、fail和eof则在对应错误位被置位时返回true。此外，在badbit被置位时，fail也会返回true。这意味着，使用good或fail是确定流的总体状态的正确方法。实际上，我们将流当做条件使用的代码就等价于！fail()。而eof和bad操作只能表示特定的错误。

### 管理条件状态