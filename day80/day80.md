2022.12.06



## 11.2 关联容器概述
关联容器(有序的和无序的)都支持普通容器操作。关联容器不支持顺序容器的位置相关的操作，例如push_front或push_back。原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。

除了与顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作和类型别名。此外，无序容器还提供一些用来调整哈希性能的操作。

关联容器的迭代器都是双向的。

### 11.2.1 定义关联容器
如前所示，当定义一个map时，必须既指明关键字类型又指明值类型:而定义一个set时，只需指明关键字类型，因为set中没有值。每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器。我们也可以将关联容器初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化关联容器，只要这些值可以转化为容器所需类型就可以。在新标准下，我们也可以对关联容器进行值初始化:

```c++
map<string, size_t> word_count;  // 空容器
// 列表初始化
set<string> exclude = {"the", "but", "and"};
// 三个元素;authors将姓映射为名
map<string, string> authors = { {"Joyce", "James"}, {"Austen", "Jane"} };
```

与以往一样，初始化器必须能转换为容器中元素的类型。对于set，元素类型就是关键字类型。

当初始化一个map时，必须提供关键字类型和值类型。我们将每个关键字-值对包围在花括号中:

```c++
{key, value}
```

来指出它们一起构成了map中的一个元素。在每个花括号中，关键字是第一个元素，值是第二个。因此，authors将姓映射到名，初始化后它包含三个元素。

### 初始化Multimap或multiset
一个map或set中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它。容器multimap和和multiset没有此限制，它们都允许多个元素具有相同的关键字。例如，在我们用来统计单词数量的map时，每个单词只能有一个元素。另一方面，在一个词典中，一个特定的单词则可具有多个与之关联的词义。

下面的例子展示了具有唯一关键字的容器与允许重复关键字容器之间的区别。首先，我们将创建一个名为ivec的保存int的vector，它包含20个元素:0到9每个整数有两个拷贝。我们将使用此vector初始化一个set和一个multiset:

```c++
// 定义一个有20个元素的vector，保存0到9每个整数的两个拷贝
vector<int> ivec;
for (vector<int>::size_type i = 0; i != 10; ++i) {
    ivec.push_back(i);
    ivec.push_back(i);
}
// iset包含来自ivec的不重复的元素；miset包含所有20个元素
set<int> iset(ivec.cbegin(), ivec.cend());
multiset<int> miset(ivec.cbegin(), ivec.cend());
cout << ivec.size() << endl;  // 打印20
cout << iset.size() << endl;  // 打印10
cout << miset.size() << endl; // 打印20
```

即使我们用整个ivec容器来初始化iset，它也只含有10个元素:对应ivec中每个不同的元素。另一方面，miset有20个元素，与ivec中的元素数量一样多。

## 11.2.2关键字类型的要求
关联容器对其关键字类型有一些限制。对于有序容器————map,multimap,set以及multiset，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的<运算符来比较两个关键字。在集合类型中，关键字类型就是元素类型；在映射类型中，关键字类型是元素的第一部分的类型。

**Note:传递给排序算法的可调用对象必须满足与关联容器中关键字一样的类型要求**

### 有序容器的关键字类型
可以向一个算法提供我们自己定义的比较操作，与之类似，也可以提供自己定义的操作来代替关键字上的<运算符。所提供的操作必须在关键字类型上定义一个严格弱序(strict weak ordering)。可以将严格弱序看做"小于等于"，虽然实际定义的操作可能是一个复杂的函数。无论我们怎样定义比较函数，它必须具备如下基本性质:

> + 两个关键字不能同时"小于等于"对方；如果k1"小于等于"k2，那么k2绝不能"小于等于"k1。
> + 如果k1"小于等于"k2，且k2"小于等于"k3，那么k1必须"小于等于"k3。
> + 如果存在两个关键字,任何一个都不"小于等于"另一个,那么我们成这两个关键字是"等价的"。如果k1"等价于"k2，且k2"等价于"k3，那么k1必须"等价于"k3。

如果两个关键字是等价的(即，任何一个都不"小于等于"另一个)，那么容器将它们视作相等来处理。当用作map的关键字时，只能有一个元素与这两个关键字关联，我们可以用两者中任意一个来访问对应的值。

**Note:在实际编程中，重要的是，如果一个类型定义了"行为正常"的<运算符，则它可以用作关键字类型**

### 使用关键字类型的比较函数
用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型，必须在定义关联容器类型时提供此操作的类型。如前所述，用尖括号支出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟着元素类型给出。

在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器(对象)时，才会以构造函数参数的形式提供真正的比较操作(其类型必须与在尖括号中指定的类型相吻合)。

例如，我们不能直接定义一个Sales_data的multiset，因为Sales_data没有< 运算符。但是,可以用comparedIsbn函数来定义一个multiset。此函数在Sales_data对象的ISBN成员上定义了一个严格弱序。函数compareIsbn应该像下面这样定义:

```c++
bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs) {
    return lhs.isbn() < rhs.isbg();
}
```

为了使用自己定义的操作操作，在定义multiset时，我们必须提供两个类型:关键字类型Sales_data，以及比较操作类型————应该是一种函数指针类型，可以指向compareIsbn。当定义此容器类型的对象时，需要提供想要使用的操作的指针。在本例中，我们提供一个指向comparedIsbn的指针:

```c++
// bookstore中多条记录可以有相同的ISBN
// bookstore中的元素以ISBN的顺序进行排列
multiset<Sales_data, decltype(compareIsbn) *> bookstore(compareIsbn);
```

此处，我们使用decltype来指出自定义操作的类型。记住，当用decltype来获得一个函数指针类型时，必须加上一个*来指出我们要使用一个给定函数类型的指针。用comparedIsbn来初始化bookstore对象，这表示当我们向bookstore添加元素时，通过调用compareIsbn来为这些元素排序。即，bookstore中的元素将按它们的ISBN成员的值排序。可以用compareIsbn代替&compareIsbn作为构造函数的参数，因为当我们使用一个函数的名字时，在需要的情况信息它会自动转化为一个指针。当然，使用&compareIsbn的效果也是一样的。